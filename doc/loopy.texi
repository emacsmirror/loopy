\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename loopy.info
@settitle Loopy: A Looping and Iteration Macro
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@dircategory Emacs
@direntry
* Loopy: (loopy).       A looping and iteration macro.
@end direntry

@finalout
@titlepage
@title Loopy: A Looping and Iteration Macro
@author Earl Hyatt
@end titlepage

@contents

@ifnottex
@node Top
@top Loopy: A Looping and Iteration Macro

@code{loopy} is a macro meant for iterating and looping.  It is similar in usage to
@code{cl-loop} (@ref{Loop Facility,,,cl,}) but uses symbolic expressions rather than
keywords.

For most use cases, @code{loopy} should a nice substitute for @code{cl-loop} and
complementary to the features provided by the @samp{seq} (@ref{Sequence Functions,,,elisp,})
and @samp{cl-lib} (@ref{Top,,,cl,}) libraries and Emacs's regular looping and mapping features.

@end ifnottex

@menu
* Introduction::                 A short overview.
* Basic Concepts::               Basic information about `loopy' and its loops.
* Special Macro Arguments::      Creating the environment of the loop.
* Loop Commands::                The main features of `loopy'.
* Special Variables::
* Destructuring Macros::         Destructuring outside of the loop.
* The @code{loopy-iter} Macro::  Embedding loop commands in arbitrary code.
* Using Flags::                  Using flags to change behavior.
* Custom Aliases::               How to add one's own aliases.
* Custom Commands::              Extending `loopy' with personal commands.
* Comparing to @code{cl-loop}::  Why `loopy' instead of `cl-loop'.
* Translating to and from @samp{cl-loop}:: Converting `cl-loop' to `loopy', and vice versa.
* Real-World Examples::          Extra example of how one could use `loopy'.
* Macro Argument and Loop Command Index::
* Variable Index::
* Concept Index::

@detailmenu
--- The Detailed Node Listing ---

Loop Commands

* Generic Evaluation::           Setting variables, evaluating expressions, etc.
* Iteration::                    Iterating through sequences, etc.
* Accumulation::                 Accumulating values into new sequences, aggregating values, etc.
* Boolean::                      Testing whether a condition holds true.
* Control Flow::                 When to run loop commands.
* Sub-loops::                    Running a loop within a loop.

Iteration

* Generic Iteration::            Looping a certain number of times.
* Numeric Iteration::            Iterating through numbers.
* Sequence Iteration::           Iterating through sequences.
* Sequence Index Iteration::     Iterating through indices without accessing values.
* Sequence Reference Iteration:: Iterating through places/fields in sequences.

Control Flow

* Conditionals::                 Choosing if commands should run.
* Skipping Cycles::              Immediately beginning the next iteration.
* Early Exit::                   Leaving the loop early, with or without returning values.

Custom Commands

* Background Info::              The internals of `loopy'.
* Hello World::                  A minimal working example.
* An @code{always} Command::     Adding a feature from `cl-loop'.
* Finding More Examples::

Translating to and from @samp{cl-loop}

* For Clauses::
* Iteration Clauses::
* Accumulation Clauses::
* Other Clauses::

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

The @code{loopy} macro is used to generate code for a loop, similar to @code{cl-loop}.
Unlike @code{cl-loop}, @code{loopy} uses symbolic expressions instead of ``clauses''.

@lisp
;; A simple usage of `cl-loop':
(cl-loop for i from 1 to 10
         if (cl-evenp i) collect i into evens
         else collect i into odds
         end ; This `end' keyword is optional here.
         finally return (list odds evens))

;; How it could be done using `loopy':
(loopy (numbers i 1 10)
       (if (cl-evenp i)
           (collect evens i)
         (collect odds i))
       (finally-return odds evens))
@end lisp

@code{loopy} supports destructuring for iteration commands like @samp{list} and
accumulation commands like @samp{sum} or @samp{collect}.

@lisp
;; Summing the nth elements of arrays:
;; => (8 10 12 14 16 18)
(loopy (list (list-elem1 list-elem2)
             '(([1 2 3] [4 5 6])
               ([7 8 9] [10 11 12])))
       (sum [sum1 sum2 sum3] list-elem1)
       (sum [sum4 sum5 sum6] list-elem2)
       (finally-return sum1 sum2 sum3 sum4 sum5 sum6))

;; Or, more simply:
;; => (8 10 12 14 16 18)
(loopy (list list-elem '(([1 2 3] [4 5 6])
                         ([7 8 9] [10 11 12])))
       (sum ([sum1 sum2 sum3] [sum4 sum5 sum6])
            list-elem)
       (finally-return sum1 sum2 sum3 sum4 sum5 sum6))

;; Separate the elements of sub-list:
;; => ((1 3) (2 4))
(loopy (list i '((1 2) (3 4)))
       (collect (elem1 elem2) i)
       (finally-return elem1 elem2))
@end lisp

The @code{loopy} macro is configurable and extensible.  In addition to writing one's
own ``loop commands'' (such as @samp{list} in the example below), by using ``flags'',
one can choose whether to instead use @code{pcase-let}, @code{seq-let}, or even the Dash
library for destructuring.

@lisp
;; Use `pcase' to destructure array elements:
;; => ((1 2 3 4) (10 12 14) (11 13 15))
(loopy (flag pcase)
       (array (or `(,car . ,cdr) digit)
              [1 (10 . 11) 2 (12 . 13) 3 4 (14 . 15)])
       (if digit
           (collect digits digit)
         (collect cars car)
         (collect cdrs cdr))
       (finally-return digits cars cdrs))

;; Using the default destructuring:
;; => ((1 2 3 4) (10 12 14) (11 13 15))
(loopy (array elem [1 (10 . 11) 2 (12 . 13) 3 4 (14 . 15)])
       (if (numberp elem)
           (collect digits elem)
         (collect (cars . cdrs) elem))
       (finally-return digits cars cdrs))
@end lisp

Variables like @samp{cars}, @samp{cdrs}, and @samp{digits} in the example above are
automatically @code{let}-bound so as to not affect code outside of the loop.

@code{loopy} has arguments for binding (or not binding) variables, executing code
before/after the loop, executing code only if the loop completes, and for
setting the macro's return value (default @code{nil}).  This is in addition to the
looping features themselves.

All of this makes @code{loopy} a useful and convenient choice for looping and
iteration.

That being said, Loopy is not yet feature complete.  Please request features
or report problems in this project’s @uref{https://github.com/okamsn/loopy/issues, issues tracker}.  While most cases are
covered, full feature parity with some of the more niche uses of @code{cl-loop} is
still being worked on.

@node Basic Concepts
@chapter Basic Concepts

Except for an optional loop name, all arguments of the @code{loopy} macro are
symbolic expressions that create a loop, assigns variables in the lexical
environment that surrounds the loop, adds code that runs before/after the
loop, and sets the ultimate return value of the macro.

For convenience and clarity, symbolic expressions that generate code in the
loop body are called ``loop commands'' (@ref{Loop Commands}).  Symbolic
expressions that generate code around the loop are called ``special macro
arguments'' or just ``macro arguments'' as opposed to ``loop commands''
(@ref{Special Macro Arguments}).

``Loop commands'' are the main feature of the @code{loopy} macro, such as the @samp{list}
in @samp{(list i '(1 2 3))}.  A command inserts code into the loop body, but can
also perform additional setup like initializing variables.  Many commands set
a condition for ending the loop.

The loop ends when any condition required by a loop command evaluates to
false.  If no conditions are needed, the loop runs infinitely until a @samp{return}
or @samp{return-from} command is reached (@ref{Early Exit, , Exiting the Loop Early}).

Except when using accumulating loop commands (@ref{Accumulation, , Accumulation Commands}), return
values must be stated explicitly, either as an early return in the loop body
via the @samp{return} or @samp{return-from} commands, or as part of the @samp{finally-return}
macro argument.  @code{nil} is returned by default.

The macro is configurable.  One can add custom commands (@ref{Custom Commands}), add
custom command aliases (@ref{Custom Aliases}), and specify macro options for a
particular loop (@ref{Using Flags}).  Each of these ideas is explained in detail
later in this document.

@node Special Macro Arguments
@chapter Special Macro Arguments

@cindex special macro argument
There are only a few special macro arguments. One, an unquoted symbol, is
taken as the loop's name. The others, listed below, are symbolic expressions
that begin with a keyword or one of their aliases. You do not need to use all
of them.

If a macro argument does not match one of these special few, @code{loopy} will
attempt to interpret it as a loop command, and throw an error if that fails.

These special macro arguments are always processed before loop commands,
regardless of the order of the arguments passed to @code{loopy}.  As they are not
loop commands, they cannot occur in sub-loops (@ref{Sub-loops}).

@findex with, let*
@table @asis
@item @samp{with}, @samp{let*}, @samp{init}
Declare variables before the loop.  This can also
be used to initialize variables referenced by loop commands.

@lisp
;; => (4 5 6)
(loopy
 (with (a 1)          ; Set `a' to 1.
       (b (1+ a)))    ; Set `b' to 1+1=2.
 (list i '(1 2 3))    ; Bind `i' to elements of the list.
 (collect (+ i a b))) ; Collect sum of `a', `b', and each `i' into a list.

;; => 16
(loopy
 (let* (my-sum 10))       ; Bind `my-sum' to 10.
 (list i '(1 2 3))        ; Bind `i' to elements of the list.
 (sum my-sum i)           ; Set `my-sum' to `i' + `my-sum'.
 (finally-return my-sum)) ; Return the value of `my-sum'.
@end lisp
@end table

@findex without, no-init
@table @asis
@item @samp{without}, @samp{no-with}, @samp{no-init}
Variables that @code{loopy} should not try to
initialize.  @code{loopy} tries to initialize all the variables it uses in a
@code{let}-like form, but that isn’t always desired.

@lisp
;; Without `without', `loopy' would try to initialize `a' to nil, which would
;; overwrite the value of 5 above.

(let ((a 5))
  (loopy (without a)        ; Don't initialize `a'.
         (until (zerop a))  ; Leave loop when `a' equals 0.
         (collect a)        ; Collect the value of `a' into a list.
         (expr a (1- a))))  ; Set `a' to the value of `(1- a)'.

(let ((a 5))
  (loopy (no-init a)
         (while (not (zerop a)))
         (collect a)
         (set a (1- a))))
@end lisp
@end table

@findex before-do, before
@table @asis
@item @samp{before-do}, @samp{before}, @samp{initially-do}, @samp{initially}
Run Lisp expressions
before the loop starts.

@lisp
;; = > (6 7 8)
(loopy (with (a 1) (b 2))          ; Set `a' to 1 and `b' to 2.
       (before-do (setq a (1+ a))  ; Add 1 to `a'.
                  (setq b (1+ b))) ; Add 1 to `b'.
       (list i '(1 2 3))           ; Set `i' to each element in the list.
       (collect (+ i a b)))        ; Collect each sum into a list.

;; => (1 2 3)
(loopy (with (a 1))
       ;; Message before the loop starts:
       (initially (message "Starting loop..."))
       (list i '(1 2 3))
       (collect i))
@end lisp
@end table

@findex after-do, after, else-do, else
@table @asis
@item @samp{after-do}, @samp{after}, @samp{else-do}, @samp{else}
Run Lisp expressions after the
loop successfully completes.  This is similar to Python’s @code{else} statement
after a @code{for} or @code{while} loop.

@lisp
;; Messages that no odd number was found:
;; => nil
(loopy (list i '(2 4 6 8))
       (when (cl-oddp i)
         (do (message "Odd number found."))
         (return t))                  ; Make the loop return `t'.
       (after-do
        (message "No odd number found.")
        ;; The macro already return `nil' by default,
        ;; but one can still use `cl-return' to be more explicit.
        (cl-return nil)))

;; Messages that an odd number was found:
;; => t
(loopy (list i '(2 4 5 8))
       (when (cl-oddp i)
         (do (message "Odd number found."))
         (return t))
       (else (message "No odd number found.")))
@end lisp
@end table

@findex finally-do, finally
@table @asis
@item @samp{finally-do}, @samp{finally}
Always run Lisp expressions after the loop
exits.

@lisp
(loopy (list i '(1 2 3))
       (when (cl-oddp i) (break))
       (after-do (message "This not messaged."))
       (finally-do (message "This always messaged.")))

(loopy (list i '(1 2 3))
       (when (cl-oddp i) (break))
       (after-do (message "This not messaged."))
       (finally (message "This always messaged.")))
@end lisp
@end table

@findex finally-return
@table @asis
@item @samp{finally-return}
Return a value, regardless of how the loop completes.
Accumulation commands have an implicit return value, but this argument
overrides them.  Specifying multiple return values is the same as returning
a list of those values.  This is convenient when used with @code{seq-let},
@code{pcase-let}, @code{cl-destructuring-bind}, and the like.

@lisp
;; => "This string always returned."
(loopy (list i '(1 2 3))
       (when (cl-oddp i)
         (return "This return value is over-ridden."))
       (finally-return "This string always returned."))


;; To be clear, the below code would be better expressed as
;; `(loopy (return 1 2 3))'.  In the below example,
;; `repeat' is used to avoid an infinite loop.
;;
;; => (1 2 3)
(loopy (repeat 0)  ; Run the loop itself 0 times.
       (finally-return 1 2 3))
@end lisp
@end table

@findex flag, flags
@table @asis
@item @samp{flag}, @samp{flags}
Options that change the behavior of @code{loopy} (@ref{Using Flags}).

@lisp
;; Use Dash for destructuring:
;;
;; (((1 2) (3 4)) (1 3) (2 4))
(loopy (flag dash)
       (list (whole &as a b) '((1 2) (3 4)))
       (collect wholes whole)
       (collect as a)
       (collect bs b)
       (finally-return wholes as bs))

;; Use Seq for destructuring:
;;
;; => (1 [2 3])
(loopy (flag seq)
       (with ([a &rest b] [1 2 3]))
       (return a b))

;; Automatically split accumulations into separate variables:
;;
;; => ((1 3) (2 4))
(loopy (flag split)
       (list (i j) '((1 2) (3 4)))
       (collect i)
       (collect j))
@end lisp
@end table

@findex wrap
@table @asis
@item @samp{wrap}
A list of forms in which to wrap the loop itself (i.e., not
@samp{before-do}, @samp{after-do}, or anything else).  Each form can be either a list
or a symbol.  If a list, the loop is inserted into the end of the list.  If
a symbol, it is first converted to a list of 1 element before inserting the
loop at the end of the list.  This special macro argument is similar in use
to the Emacs Lisp macro @code{thread-last}, except that forms listed first are
applied last, as in normal Lisp code.

The main difference between using this macro argument instead of just
writing the function calls normally is that these forms can access variables
initialized by the macro and that they occur after the code in @samp{before-do}
is run.

@lisp
(loopy (wrap (let ((a 1)))
             save-match-data)
       ...)

;; Similar to
(let ((a 1))
  (save-match-data
    (loopy ...)))

;; => 6
(loopy (with (a 1))
       (before-do (cl-incf a 2))
       (wrap (progn (setq a (* 2 a))))
       (return a))
@end lisp
@end table

As stated above, all other expressions will be considered loop commands
(@ref{Loop Commands}).


@quotation Note
For convenience, the @code{while}-loop that @code{loopy} creates is wrapped by a
@code{cl-block}.  Naming the loop names this block, which is created @emph{after}
initializing variables.

The two special macro arguments @samp{before-do} and @samp{after-do} (and their aliases)
also occur within this @code{cl-block}, before and after the loop, respectively.
This has 2 consequences:

@enumerate
@item
Using @code{cl-return} in @samp{before-do} will prevent the both loop and @samp{after-do}
code from running.

@item
Using @code{cl-return} or an early exit command (@ref{Early Exit}) in the loop will
prevent the @samp{after-do} code from running.  For this reason, @samp{after-do} is
run if and only if the loop completes successfully, hence the alias
@samp{else-do} and the similarity to Python's @code{else} statement for loops.
@end enumerate

These three sections (@samp{before-do}, @samp{after-do}, and the @code{while}-loop itself)
are the only structures that occur within the @code{cl-block}.  Using @code{cl-return}
in @samp{before-do}, for example, will not stop code in @samp{finally-do} from running
or values listed in @samp{finally-return} from being returned.

@end quotation

@node Loop Commands
@chapter Loop Commands

@cindex loop command
If a macro argument does not match one of the previously listed special macro
arguments (@ref{Special Macro Arguments}), @code{loopy} will attempt to treat it as a
loop command.  Loop commands are only valid as a top-level argument to the
macro, or inside another loop command.

Therefore, these macro calls are valid:

@lisp
(loopy (list i '(1 2 3))
       (collect coll i)
       ;; Special macro argument:
       (finally-return coll))

;; Implicit accumulation variable and implicit return value:
(loopy (list i '(1 2 3))
       (collect i))
@end lisp

and this is not:

@lisp
(loopy (with (list i '(1 2 3)))
       (finally-return (collect coll i)))
@end lisp

Trying to use loop commands where they don't belong will result in errors
when the code is evaluated.

You should keep in mind that commands are evaluated in order.  This means that
attempting to do something like the below example might not do what you
expect, as @samp{i} is assigned a value from the list after collecting @samp{i} into
@samp{coll}.

@float Listing,orgf028415
@lisp
;; => (nil 1 2)
(loopy (collect coll i)
       (list i '(1 2 3))
       (finally-return coll))
@end lisp
@caption{An example of how loop commands are evaluated in order.}
@end float

For convenience and understanding, the same command might have multiple names,
called @dfn{aliases}.  For example, the command @samp{expr} has an alias
@samp{set}, because @samp{expr} is used to set a variable to the value of an expression.
You can add custom aliases using the function @code{loopy-defalias}, which modifies
the user option @code{loopy-command-aliases} (@ref{Custom Aliases}).

Some commands take optional arguments.  For example, the command @samp{list} can
take a function as an optional argument, which affects how that iterates
through the elements in the list.

For simplicity, the commands are described using the following notation:

@itemize
@item
If a command has multiple names, the names are separated by a vertical
bar, such as in @samp{expr|set}.
@item
@samp{VAR} is an unquoted symbol that will be used as a variable name, such as
@samp{i} in @samp{(list i my-list)}.
@item
@samp{FUNC} is a quoted Lisp function name, such as @code{#'my-func} or @code{'my-func}, a
variable whose value is a function, or a @code{lambda} expression.
@item
@samp{NAME} is an unquoted name of a loop (or, more accurately, of a
@samp{cl-block}).
@item
@samp{EXPR} is a single Lisp expression, such as @samp{(+ 1 2)}, @samp{'(1 2 3)},
@samp{my-var}, or @samp{(some-function my-var)}.  @samp{EXPRS} means multiple expressions.
Really, we are concerned with the value of the expression, not the
expression itself.
@item
@samp{CMD} is a loop command, as opposed to a normal Lisp expression.
@samp{(list i '(1 2 3))}, @samp{(repeat 5)}, and @samp{(return-from outer-loop 7)}
are examples of loop commands.  @samp{CMDS} means multiple commands.
@item
Optional arguments are surround by brackets.  @samp{[EXPR]} is an optional
expression, and @samp{[CMD]} is an optional command.  By extension,
@samp{[EXPRS]} is equivalent to @samp{[EXPR [EXPR [...]]]}, and @samp{[CMDS]} to
@samp{[CMD [CMD [...]]]}.
@item
Optional keyword arguments are shown as @samp{&key key1 key2 ...}, where @samp{key1},
@samp{key2}, and so on are the literal keywords.  Just like in functions,
keywords must be prefixed by a colon (``:'').  For example, the iteration
command @samp{nums} has a keyword argument @samp{by}, which can be given a value using
@samp{:by SOME-EXPRESSION}.
@end itemize


Generally, @samp{VAR} is initialized to @code{nil}, but not always.  This document
tries to note when that is not the case.

@cindex variable destructuring
For convenience, @samp{VAR} can be a sequence, either a list or a vector (as a
stand-in for an array), of symbols instead of a single symbol.  This tells the
command to “de-structure” the value of @samp{EXPR}, similar to the functions
@code{seq-let}, @code{cl-destructuring-bind}, and @code{pcase-let}.  This sequence of symbols
can be shorter than the destructured sequence, @emph{but not longer}.  If shorter,
the unassigned elements of the list are simply ignored.

An element in the sequence @samp{VAR} can be one of the following:
@itemize
@item
A positional variable which will be bound to the corresponding element in
the sequence.  These variables can be recursive.

@lisp
;; ((1 2 3) (4 5 6))
(loopy (list [i (j k)] '([1 (2 3)] [4 (5 6)]))
       (collect (list i j k)))
@end lisp

@item
@samp{&whole}: If @samp{&whole} is the first element in the sequence, then the second
element names a variable that holds the entire value of the destructured
value.

@lisp
;; => (((1 2 3) 1 2 3) ((4 5 6) 4 5 6))
(loopy (list (&whole whole i j k)  '((1 2 3) (4 5 6)))
       (collect (list whole i j k)))
@end lisp

@item
@samp{&rest}: A variable named after @samp{&rest} contains the remaining elements of
the destructured value.  Alternatively, one can use dotted notation in
lists.  These variables can be recursive.

@lisp
;; => ((1 [2 3]) (4 [5 6]))
(loopy (list [i &rest j] '([1 2 3] [4 5 6]))
       (collect (list i j)))

;; => ((1 (2 3)) (4 (5 6)))
(loopy (list (i . j) '((1 2 3) (4 5 6)))
       (collect (list i j)))

;; Works the same as above:
(loopy (list (i &rest j) '((1 2 3) (4 5 6)))
       (collect (list i j)))

;; => ((1 2 3) (4 5 6))
(loopy (list (i . [j k]) '((1 . [2 3]) (4 . [5 6])))
       (collect (list i j k)))

;; Works the same as above:
(loopy (list (i &rest [j k]) '((1 . [2 3]) (4 . [5 6])))
       (collect (list i j k)))
@end lisp

@item
@samp{&key}: Variables named after @samp{&key} are transformed into keys whose values
will be sought using @code{plist-get}.  Optionally, these variables can be a list
of 2 elements: (1) the variable and (2) a default value if that key isn't
found.
@itemize
@item
Currently, only lists support this destructuring.
@item
Keys are sought in values after those bound to positional variables, which
can be the same values to the variable named by @samp{&rest} when both are
used.
@item
@samp{&key} and @samp{&rest} can be used in any order, but @samp{&key} must come before
the dot in dotted lists.
@end itemize

@lisp
;; => ((1 2) (4 5))
(loopy (list (&key a b) '((:b 2 :c 3 :a 1)
                          (:a 4 :b 5 :c 6)))
       (collect (list a b)))

;; Giving a default value:
;; Note that `nil' is not the same as a missing value.
;; => ((1 2 nil 25) (4 5 24 25))
(loopy (list (&key a b (c 24) (d 25)) '((:b 2 :c nil :a 1)
                                        (:a 4 :b 5)))
       (collect (list a b c d)))

;; Keys are only sought after positional variables:
;; => ((1 2 :k1 'ignored 3))
(loopy (array (a b c d &key k1) [(1 2 :k1 'ignored :k1 3)])
       (collect (list a b c d k1)))

;; If `&rest' is used, keys are sought only in that variable:
;; => ((1 (:k1 3) 3))
(loopy (array (a &rest b &key k1) [(1 :k1 3)])
       (collect (list a b k1)))

;; The below two examples work the same as the above:

(loopy (array (a &key k1 &rest b) [(1 :k1 3)])
       (collect (list a b k1)))

(loopy (array (a &key k1 . b) [(1 :k1 3)])
       (collect (list a b k1)))
@end lisp
@end itemize


Alternative destructuring systems can be used via flags (@ref{Using Flags}).  For more
flexible pattern matching, see the flag @samp{pcase}.  For more kinds of key-value
destructuring, see the flag @samp{dash} provided by the package @samp{loopy-dash}.

Most commands that assign variables can use destructuring, but not all kinds
of destructuring make sense in all situations.  Accumulation commands
(@ref{Accumulation}) and commands iterating through @code{setf}-able places in
a sequence (@ref{Sequence Reference Iteration}) have their own kinds of
destructuring.  They are explained more in their respective sections.

@menu
* Generic Evaluation::           Setting variables, evaluating expressions, etc.
* Iteration::                    Iterating through sequences, etc.
* Accumulation::                 Accumulating values into new sequences, aggregating values, etc.
* Boolean::                      Testing whether a condition holds true.
* Control Flow::                 When to run loop commands.
* Sub-loops::                    Running a loop within a loop.
@end menu

@node Generic Evaluation
@section Generic Evaluation

@findex do
@table @asis
@item @samp{(do EXPRS)}
Evaluate multiple Lisp expressions, like a @samp{progn}.

You cannot include arbitrary code in the loop body.  Trying to do so will
result in errors, as the macro will attempt to interpret such code as a
command.

@lisp
(loopy (list i '(1 2 3))
       (do (message "%d" i)))
@end lisp
@end table

@findex expr, exprs, set
@table @asis
@item @samp{(expr|exprs|set VAR [EXPRS] &key init)}
Bind @samp{VAR} to each @samp{EXPR} in
order.  Once the last @samp{EXPR} is reached, it is used repeatedly for the rest
of the loop.  With no @samp{EXPR}, @samp{VAR} is repeatedly bound to @code{nil}.

If @samp{INIT} is provided, use that as the initial value of @samp{VAR}.  This could
also be achieved by specifying a value using the @samp{with} special macro
argument.  When destructuring, each variable is initialized to @samp{INIT}, not
a destructured part of @samp{INIT}.

@quotation Note
@samp{expr} does @emph{not} behave the same as @code{setq} in all situations.

While @samp{expr} can take multiple arguments, it only assigns the value of one
expression to one variable during each iteration of the loop (unless using
destructuring).  It cannot take pairs of variables and values in the same
way that @code{setq} does.

Furthermore, variables assigned by @samp{expr} (and other commands) are by
default @code{let}-bound around the loop and generally initialized to @code{nil}.
This means that doing @samp{(expr VAR EXPR)} will not, by default, affect
variables outside of the loop in the same way that using @samp{(do (setq VAR
     EXPR))} would.

@end quotation

@lisp
;; => '(1 2 3 3 3)
(loopy (repeat 5)
       (expr i 1 2 3)
       (collect coll i)
       (finally-return coll))

;; => '(0 1 2 3 4)
(loopy (repeat 5)
       (expr i 0 (1+ i))
       (collect coll i)
       (finally-return coll))

;; Note that `i' is initialized to 0, and set to 1 in
;; the middle of the first cycle of the loop.
;;
;; => ((0 1 2) (1 2 3))
(loopy (repeat 3)
       (collect befores i)
       (expr i 1 (1+ i) :init 0)
       (collect afters i)
       (finally-return befores afters))

;; Note that using `with' has a similar effect.
;; => (0 1 2)
(loopy (with (i 0))
       (repeat 3)
       (collect i)
       (expr i 1 (1+ i)))
@end lisp
@end table

@findex group
@table @asis
@item @samp{(group|command-do [CMDS])}
Evaluate multiple loop commands, as if in a
@samp{progn}.  This is similar to @samp{do}, but runs commands instead of normal Lisp
expressions.  Currently, this command is only useful when used with the
@samp{if} command.

@lisp
;; Report whether an even number is found, or return the sum of
;; the list's elements.  To be clear, this is not an idiomatic example.

;; Returns sum:
;; => 9
(loopy (list i '(1 3 5))
       (if (cl-evenp i)
           (group
            (do (message "Even found."))
            (return i))
         (sum i)))

;; Returns the detected even number:
;; => 2
(loopy (list i '(1 3 2 5))
       (if (cl-evenp i)
           (command-do
            (do (message "Even found."))
            (return i))
         (sum i)))
@end lisp
@end table

@findex prev-expr, prev
@table @asis
@item @samp{(prev-expr|prev VAR VAL &key init back)}
Bind @samp{VAR} to a value @samp{VAL}
from a previous cycle in the loop.  @samp{VAR} is initialized to @samp{INIT} or nil.
With @samp{BACK}, use the value from that many cycles previous.

As in @samp{expr}, when using destructuring, each variable is initialized to
@samp{INIT}, not a destructured part of @samp{INIT}.

@lisp
;; => (nil 1 2 3 4)
(loopy (list i '(1 2 3 4 5))
       (prev-expr j i)
       (collect j))

;; (nil nil nil 1 2)
(loopy (list i '(1 2 3 4 5))
       (prev-expr j i :back 3)
       (collect j))

;; => ((7 7 1 3) (7 7 2 4))
(loopy (list i '((1 2) (3 4) (5 6) (7 8)))
       (prev-expr (a b) i :back 2 :init 7)
       (collect c1 a)
       (collect c2 b)
       (finally-return c1 c2))

;; NOTE: `prev-expr' keeps track of the previous value of `i',
;;       even when `j' isn't updated.
;;
;; => (first-val first-val 2 2 4 4 6 6 8 8)
(loopy (numbers i 1 10)
       (when (cl-oddp i)
         (prev-expr j i :init 'first-val))
       (collect j))
@end lisp
@end table

@node Iteration
@section Iteration

Iteration commands bind local variables and determine when the loop ends.  If
no command sets an ending condition, then the loop runs forever.  Infinite
loops can be exited by using early-exit commands (@ref{Early Exit}) or
boolean commands (@ref{Boolean}).

Iteration commands must occur in the top level of the @code{loopy} form or in a
@samp{sub-loop} command.  Trying to do something like the below will signal an
error.

@lisp
(loopy (list i '(1 2 3 4 5))
       (when (cl-evenp i)
         ;; Can't use `list' in a `when'.
         ;; Will signal an error.
         (list j '(6 7 8 9 10))
         (collect j)))
@end lisp


In @code{loopy}, iteration commands are named after what they iterate through.
For example, the @samp{array} and @samp{list} commands iterate through the elements of
arrays and lists, respectively.  For the sake of familiarity, these commands
also have aliases based on their equivalent @samp{for}-clause from @code{cl-loop}.  To
translate @samp{for VAR in LIST} from @code{cl-loop}, one can use either
@samp{(list VAR LIST)} or @samp{(in VAR LIST)}.

@menu
* Generic Iteration::            Looping a certain number of times.
* Numeric Iteration::            Iterating through numbers.
* Sequence Iteration::           Iterating through sequences.
* Sequence Index Iteration::     Iterating through indices without accessing values.
* Sequence Reference Iteration:: Iterating through places/fields in sequences.
@end menu

@node Generic Iteration
@subsection Generic Iteration

@findex repeat
@table @asis
@item @samp{(repeat [VAR] EXPR)}
Add a condition that the loop should stop after
@samp{EXPR} iterations.  If specified, @samp{VAR} starts at 0, and is incremented by
1 at the end of the loop.

@lisp
(loopy (repeat 3)
       (do (message "Messaged three times.")))

(loopy (repeat i 3)
       (do (message "%d" i)))
@end lisp
@end table

@node Numeric Iteration
@subsection Numeric Iteration

For iterating through numbers, there is the general @samp{nums} command, and its
variants @samp{nums-up} and @samp{nums-down}.

@findex num, nums, number, numbers
@table @asis
@item @samp{(nums|num|number|numbers VAR [START [END]] &key KEYS)}
Iterate through
numbers.  @samp{KEYS} is one or several of @samp{from}, @samp{upfrom}, @samp{downfrom}, @samp{to},
@samp{upto}, @samp{downto}, @samp{above}, @samp{below}, and @samp{by}.

The command @samp{nums} is used to iterate through numbers.  For example, @samp{(nums
      i 1 10)} is similar to @samp{(list i (number-sequence 1 10))}, and @samp{(nums i 3)}
is similar to @samp{(expr i 3 (1+ i))}.

To balance convenience and similarity to other commands, @samp{nums} has a
flexible argument list.  In its most basic form, it uses no keywords and
takes a starting value and an ending value.  The ending value is inclusive.

@lisp
;; => (1 2 3 4 5)
(loopy (nums i 1 5)
       (collect i))
@end lisp

If the ending value is not given, then the value is incremented by 1
without end.

@lisp
;; => (7 8 9 10 11 12 13 14 15 16)
(loopy (repeat 10)
       (nums i 7)
       (collect i))
@end lisp

To specify the step size, one can use the keyword @samp{:by}.  The step size
argument should always be positive.

@lisp
;; => (1 3 5)
(loopy (nums i 1 5 :by 2)
       (collect i))

;; => (7 9 11 13 15 17 19 21 23 25)
(loopy (repeat 10)
       (nums i 7 :by 2)
       (collect i))

;; => (1 2.5 4.0)
(loopy (nums i 1 5 :by 1.5)
       (collect i))
@end lisp

By default, the variable's value starts at 0 and increases by 1.  To
specify that the value should be increasing or decreasing, one can use the
keywords @samp{:downfrom}, @samp{:downto}, @samp{:upfrom}, and @samp{:upto}.  The keywords
@samp{:from} and @samp{:to} don't by themselves specify a direction.

@lisp
;; => (3 2 1)
(loopy (repeat 3)
       (nums i :downfrom 3)
       (collect i))

;; => (0 -1 -2 -3)
(loopy (nums i :downto -3)
       (collect i))

;; => (10 9 8 7 6 5 4 3 2)
(loopy (nums i :downfrom 10 :to 2)
       (collect i))

;; => (10 8 6 4 2)
(loopy (nums i :from 10 :downto 2 :by 2)
       (collect i))

;; => (1 2 3 4 5 6 7)
(loopy (nums i :from 1 :upto 7)
       (collect i))
@end lisp

To specify an @emph{exclusive} ending value, use the keywords @samp{:below} for
increasing values and @samp{:above} for decreasing values.

@lisp
;; => (1 2 3 4 5 6 7 8 9)
(loopy (nums i :from 1 :below 10)
       (collect i))

;; Same as
(loopy (expr i 1 (1+ i))
       (while (< i 10))
       (collect i))

;; => (10 9 8 7 6 5 4 3 2)
(loopy (nums i :from 10 :above 1)
       (collect i))

;; => (0 -1 -2)
(loopy (nums i :above -3)
       (collect i))
@end lisp
@end table


If you prefer using positional arguments to keyword arguments, you can use
the commands @samp{nums-up} and @samp{nums-down} to specify directions.  These
commands are simple wrappers of the above @samp{nums} command.

@table @asis
@item @samp{(nums-down|numsdown|numbers-down VAR START [END] &key by)}
Equivalent
to @samp{(nums VAR START [:downto END] &key by)}.  This command exists only for
convenience.

@lisp
;; => (10 8 6 4 2)
(loopy (nums-down i 10 1 :by 2)
       (collect i))
@end lisp
@end table

@table @asis
@item @samp{(nums-up|numsup|numbers-up VAR START [END] &key by)}
Equivalent to
@samp{(nums VAR START [END] &key by)}.  This command exists only for
convenience.

@lisp
;; => (1 3 5 7 9)
(loopy (nums-up i 1 10 :by 2)
       (collect i))
@end lisp
@end table

@node Sequence Iteration
@subsection Sequence Iteration

These commands provide various ways to iterate through sequences
(@ref{Sequences Arrays Vectors,,,elisp,}).

@cindex sequence element distribution
Instead of just one sequence, the @samp{array}, @samp{list}, and @samp{seq} commands can be
given multiple sequences of various sizes.  In such cases, the elements of
the sequences are @dfn{distributed}, like in the distributive property
from mathematics.  A new sequence of distributed elements is created before
the loop runs, and that sequence is used for iteration instead of the source
sequences.  As seen in the below example, the resulting behavior is similar
to that of nested loops.

@lisp
;; => ((1 3 6) (1 4 6) (1 5 6) (2 3 6) (2 4 6) (2 5 6))
(loopy (list i '(1 2) '(3 4 5) '(6))
       (collect i))

;; Gives the same result as this
(let ((result nil))
  (dolist (i '(1 2))
    (dolist (j '(3 4 5))
      (dolist (k '(6))
        (push (list i j k) result))))
  (nreverse result))

;; and this
(cl-loop for i in '(1 2)
         append (cl-loop for j in '(3 4 5)
                         append (cl-loop for k in '(6)
                                         collect (list i j k))))
@end lisp


The @samp{array} and @samp{sequence} commands can use the same keywords as the @samp{nums}
command (@ref{Numeric Iteration}) for working with the index and choosing a range
of the sequence elements through which to iterate.  In addition to those
keywords, they also have an @samp{index} keyword, which names the variable used
to store the accessed index during the loop.

Keep in mind that if used with sequence distribution, these keywords affect
iterating through the sequence of distributed elements.  That is, they do
not affect how said sequence is produced.  In the example below, see that
@code{cddr} is applied to the sequence of distributed elements. It is @emph{not}
applied to the source sequences.

@lisp
;; This code creates the sequence of distributed elements
;; ((1 4) (1 5) (1 6) (2 4) (2 5) (2 6) (3 4) (3 5) (3 6))
;; and then moves through this sequence using `cddr'.
;;
;; => ((1 4) (1 6) (2 5) (3 4) (3 6))
(loopy (list i '(1 2 3) '(4 5 6) :by #'cddr)
       (collect i))

;; Not the same as:
;; => ((1 4) (1 6) (3 4) (3 6))
(loopy (list i '(1 3) '(4 6))
       (collect i))
@end lisp


@findex array, string, across
@table @asis
@item @samp{(array|string|across VAR EXPR [EXPRS] &key KEYS)}
Loop through the
elements of the array @samp{EXPR}.  In Emacs Lisp, strings are arrays whose
elements are characters.

@samp{KEYS} is one or several of @samp{from}, @samp{upfrom}, @samp{downfrom}, @samp{to}, @samp{upto},
@samp{downto}, @samp{above}, @samp{below}, @samp{by}, and @samp{index}.  @samp{index} names the variable
used to store the index being accessed.  For others, see the @samp{nums}
command.

If multiple arrays are given, then the elements of these arrays are
distributed into an array of lists and the above keywords apply to this
new resulting array.

@lisp
(loopy (array i [1 2 3])
       (do (message "%d" i)))

;; => (1 3)
(loopy (array i [1 2 3 4] :by 2)
       (collect i))

;; Collects the integer values representing each character.
;; => (97 98 99)
(loopy (string c "abc")
       (collect c))

;; This is the same as using [(1 3) (1 4) (2 3) (2 4)].
;; => ((1 3) (1 4) (2 3) (2 4))
(loopy (array i [1 2] [3 4])
       (collect i))

;; => ((1 3) (2 3))
(loopy (array i [1 2] [3 4] :by 2)
       (collect i))
@end lisp
@end table

@findex cons, conses, on
@table @asis
@item @samp{(cons|conses|on VAR EXPR &key by)}
Loop through the cons cells of
@samp{EXPR}.  Optionally, find the cons cells via function @samp{by} instead of
@samp{cdr}.

@lisp
(loopy (cons i '(1 2 3))
       (collect coll i)
       (finally-return coll)) ; => ((1 2 3) (2 3) (3))
@end lisp
@end table

@findex list, in, each
@table @asis
@item @samp{(list|in|each VAR EXPR [EXPRS] &key by)}
Loop through each element of
the list @samp{EXPR}.  Optionally, update the list by @samp{by} instead of @samp{cdr}.

If multiple lists are given, distribute the elements of the lists into one
new list.  In such cases, @samp{by} applies to the new list, not the arguments
of the command.

@lisp
(loopy (list i (number-sequence 1 10 3)) ; Inclusive, so '(1 4 7 10).
       (do (message "%d" i)))

;; => ((1 4) (1 5) (1 6) (2 4) (2 5) (2 6) (3 4) (3 5) (3 6))
(loopy (list i '(1 2 3) '(4 5 6))
       (collect i))

;; => ((1 4) (1 6) (2 5) (3 4) (3 6))
(loopy (list i '(1 2 3) '(4 5 6) :by #'cddr)
       (collect i))
@end lisp
@end table

@findex map, map-pairs
@table @asis
@item @samp{(map|map-pairs VAR EXPR)}
Iterate through the dotted key-value pairs
of @samp{EXPR}, using the function @code{map-pairs} from the @samp{map.el} library.  This
library generalizes working with association lists (``alists''), property
lists (``plists''), hash-tables, and vectors.

In each dotted pair assigned to @samp{VAR}, the first element is the key and
the second element is the value.  For vectors, the key is the index.  You
should not rely on the order in which the key-value pairs are found.

These pairs are created before the loop begins.  In other words, the map
@samp{EXPR} is not processed progressively, but all at once.  Therefore, this
command can have a noticeable start-up cost when working with very large
maps.

@lisp
;; => ((a . 1) (b . 2))
(loopy (map pair '((a . 1) (b . 2)))
       (collect pair))

;; => ((a b) (1 2))
(loopy (map (key . value) '((a . 1) (b . 2)))
       (collect keys key)
       (collect values value)
       (finally-return keys values))

;; => ((:a :b) (1 2))
(loopy (map (key . value) '(:a  1 :b 2))
       (collect keys key)
       (collect values value)
       (finally-return keys values))

;; NOTE: For vectors, the keys are indices.
;; => ((0 1) (1 2))
(loopy (map (key . value) [1 2])
       (collect keys key)
       (collect values value)
       (finally-return keys values))

;; => ((a b) (1 2))
(let ((my-table (make-hash-table)))
  (puthash 'a 1 my-table)
  (puthash 'b 2 my-table)

  (loopy (map (key . value) my-table)
         (collect keys key)
         (collect values value)
         (finally-return keys values)))
@end lisp
@end table


@findex seq, sequence, elements
@table @asis
@item @samp{(seq|sequence|elements VAR EXPR [EXPRS] &key KEYS)}
Loop
through the sequence @samp{EXPR}, binding @samp{VAR} to the elements of the sequence.

@samp{KEYS} is one or several of @samp{from}, @samp{upfrom}, @samp{downfrom}, @samp{to}, @samp{upto},
@samp{downto}, @samp{above}, @samp{below}, @samp{by}, and @samp{index}.  @samp{index} names the variable
used to store the index being accessed.  For others, see the @samp{nums}
command.

If multiple sequences are given, then these keyword arguments apply to the
resulting sequence of distributed elements.

@lisp
;; => (1 2 3)
(loopy (seq i [1 2 3])
       (collect coll i)
       (finally-return coll))

;; => (0 2 4)
(loopy (seq i [0 1 2 3 4 5] :by 2)
       (collect i))

;; => (1 3 5)
(loopy (seq i [0 1 2 3 4 5 6]
            :by 2 :from 1 :to 5)
       (collect i))

;; => (5 3 1)
(loopy (seq i '(0 1 2 3 4 5 6)
            :downfrom 5 :by 2 :to 1)
       (collect i))

;; => ((1 3) (1 4) (2 3) (2 4))
(loopy (seq i [1 2] '(3 4))
       (collect i))

;; => ((1 3) (2 3))
(loopy (seq i [1 2] '(3 4) :by 2)
       (collect i))
@end lisp
@end table

@node Sequence Index Iteration
@subsection Sequence Index Iteration

This command is for iterating the a sequence's indices without accessing the
actual values of that sequence.  This is helpful if you know ahead of time
that you are only interested in a small subset of the sequence's elements.

As with the @samp{array} and @samp{seq} commands, the @samp{seq-index} command can use the
same keywords as the @samp{nums} command (@ref{Numeric Iteration}) for working with
the index and choosing a range of the sequence elements through which to
iterate.  In addition to those keywords, it also has an @samp{index} keyword,
which names the variable used to store the accessed index during the loop.

@findex seq-index, seqi, array-index, arrayi, list-index, listi, string-index, stringi
@table @asis
@item @samp{(seq-index|array-index|list-index|string-index VAR VAL &key KEYS)}
Iterate
through the indices of @samp{VAL}.

@samp{KEYS} is one or several of @samp{from}, @samp{upfrom}, @samp{downfrom}, @samp{to}, @samp{upto},
@samp{downto}, @samp{above}, @samp{below}, and @samp{by}.  For their meaning, see the @samp{nums}
command.  This command is very similar to @samp{nums}, except that it can
automatically end the loop when the final element is reached.  With
@samp{nums}, one would first need to explicitly calculate the length of the
sequence.

@lisp
;; => (97 98 99 100 101 102)
(loopy (with (my-string "abcdef"))
       (string-index idx my-string)
       (collect (aref my-string idx)))

;; Works the same as
(loopy (with (my-string "abcdef"))
       (nums idx :from 0 :below (length my-string))
       (collect (aref my-string idx)))
@end lisp

For convenience, this command also has the aliases @samp{seqi}, @samp{arrayi},
@samp{listi}, and @samp{stringi}, analogous to the command aliases @samp{seqf}, @samp{arrayf},
@samp{listf}, and @samp{stringf}.

This command does not support destructuring.

@lisp
;; => (0 1 2)
(loopy (seq-index i [1 2 3])
       (collect i))

;; => (0 1 2)
(loopy (array-index i "abc")
       (collect i))

;; => (0 1 2)
(loopy (list-index i '(1 2 3))
       (collect i))

;; => (8 6 4 2)
(loopy (with (my-seq [0 1 2 3 4 5 6 7 8 9 10]))
       (seq-index idx my-seq :from 8 :downto 1 :by 2)
       (collect (elt my-seq idx)))
@end lisp
@end table

@node Sequence Reference Iteration
@subsection Sequence Reference Iteration

These commands all iterate through @code{setf}-able places as generalized
variables (@ref{Generalized Variables,,,elisp,}).  These generalized variables
are commonly called ``references'', ``fields'', or ``places''.  The below example
demonstrates using @code{(nth 1 my-list)} and @code{(aref my-array 1)} as @code{setf}-able
places.

@lisp
;; => (1 99 3 4 5)
(let ((my-list '(1 2 3 4 5)))
  (setf (nth 1 my-list) 99)
  my-list)

;; => [(1 2 3) (4 . 99)]
(let ((my-array [(1 2 3) (4 5 6)]))
  (setf (cdr (aref my-array 1)) 99)
  my-array)
@end lisp

Like other commands, field/reference commands can also use destructuring, in
which case the fields/places of the sequence are destructured into
``sub-fields'', like the @code{cdr} of the second array element in the example
above.

@quotation Caution
Be aware that using @code{setf} on an array sub-sequence named by @samp{&rest}
will only overwrite values, not truncate or grow the array.

@end quotation

@quotation Warning
Unfortunately, not all kinds of recursive destructuring work on references.
This is a limitation of how generic setters are implemented, and is not
limited to @code{loopy}.

Currently, the variable after @samp{&rest} in arrays cannot be recursive.

@end quotation

As with the @samp{array} and @samp{seq} commands, the @samp{array-ref} and @samp{seq-ref}
commands can use the same keywords as the @samp{nums} command
(@ref{Numeric Iteration}) for working with the index and choosing a range of the
sequence elements through which to iterate.  In addition to those keywords,
they also have an @samp{index} keyword, which names the variable used to store
the accessed index during the loop.

@findex array-ref, arrayf, string-ref, stringf, across-ref
@table @asis
@item @samp{(array-ref|arrayf|string-ref|stringf|across-ref VAR EXPR &key KEYS)}
Loop
through the elements of the array @samp{EXPR}, binding @samp{VAR} as a @code{setf}-able
place.

@samp{KEYS} is one or several of @samp{from}, @samp{upfrom}, @samp{downfrom}, @samp{to}, @samp{upto},
@samp{downto}, @samp{above}, @samp{below}, @samp{by}, and @samp{index}.  @samp{index} names the variable
used to store the index being accessed.  For others, see the @samp{nums}
command.

@lisp
;; => "aaa"
(loopy (with (my-str "cat"))
       (array-ref i my-str)
       (do (setf i ?a))
       (finally-return my-str))

;; => "0a2a4a6a89"
(loopy (with (my-str "0123456789"))
       (array-ref i my-str :from 1 :by 2 :to 7)
       (do (setf i ?a))
       (finally-return my-str))

;; Works the same as
(loopy (with (my-str "0123456789"))
       (nums idx 1 7 :by 2)
       (do (setf (aref my-str idx) ?a))
       (finally-return my-str))
@end lisp
@end table

@findex list-ref, listf, in-ref
@table @asis
@item @samp{(list-ref|listf|in-ref VAR EXPR &key by)}
Loop through the elements of
the list @samp{EXPR}, binding @samp{VAR} as a @code{setf}-able place.  Optionally, update
the list via function @samp{by} instead of @samp{cdr}.

@lisp
;; => (7 7 7)
(loopy (with (my-list '(1 2 3)))
       (list-ref i my-list)
       (do (setf i 7))
       (finally-return my-list))

;; Works similar to
(loopy (with (my-list '(1 2 3)))
       (nums idx :below (length my-list))
       (do (setf (nth idx my-list) 7))
       (finally-return my-list))

;; => (7 2 7)
(loopy (with (my-list '(1 2 3)))
       (list-ref i my-list :by #'cddr)
       (do (setf i 7))
       (finally-return my-list))

;; => ([1 7] [2 7])
(loopy (with (my-list '([1 2] [2 3])))
       (list-ref [_ i] my-list)
       (do (setf i 7))
       (finally-return my-list))
@end lisp
@end table

@findex map-ref, mapf
@table @asis
@item @samp{(map-ref|mapf VAR EXPR &key key)}
Loop through the values of map
@samp{EXPR}, binding @samp{VAR} as a @code{setf}-able place.  Like the command @samp{map},
this command uses the @samp{map.el} library.

@samp{key} is a variable in which to store the current key for the @code{setf}-able
place referred to by @samp{VAR}.  This is similar to the @samp{index} keyword
parameter of other commands.

Similar to @samp{map}, the keys of the map are generated before the loop is
run, which can be expensive for large maps.

Unlike @samp{map}, any duplicate keys are ignored regardless of the type of
map used.

@lisp
;; Duplicate keys are ignored.
;;
;; => (:a 8 :a 'ignored :b 10)
(loopy (with (map (list :a 1 :a 'ignored :b 3)))
       (map-ref i map)
       (do (cl-incf i 7))
       (finally-return map))

;; Works the same as the above:
;; => (:a 8 :a ignored :b 10)
(loopy (with (map (list :a 1 :a 'ignored :b 3)))
       (list (key . _) (cl-remove-duplicates (map-pairs map)
                                             :key #'car))
       (do (cl-incf (map-elt map key) 7))
       (finally-return map))

;; => (((cat . 7)       ; The map itself
;;      (dog . 7)
;;      (zebra . 7))
;;     (cat dog zebra)) ; The keys
(loopy (with (map (list (cons 'cat 1)
                        (cons 'dog 2)
                        (cons 'zebra 3))))
       (map-ref i map :key my-key)
       (do (setf i 7))
       (collect my-key)
       (finally-return map loopy-result))
@end lisp
@end table

@findex seq-ref, seqf, sequence-ref, sequencef, elements-ref
@table @asis
@item @samp{(seq-ref|seqf|sequence-ref|sequencef|elements-ref VAR EXPR &key KEYS)}
Loop
through the elements of the sequence @samp{EXPR}, binding @samp{VAR} as a
@code{setf}-able place.

@samp{KEYS} is one or several of @samp{from}, @samp{upfrom}, @samp{downfrom}, @samp{to}, @samp{upto},
@samp{downto}, @samp{above}, @samp{below}, @samp{by}, and @samp{index}.  @samp{index} names the variable
used to store the index being accessed.  For others, see the @samp{nums}
command.

@lisp
;; => (7 7 7 7)
(loopy (with (my-seq '(1 2 3 4)))
       (seq-ref i my-seq)
       (do (setf i 7))
       (finally-return my-seq))

;; => (0 cat 2 cat 4 cat 6 cat 8 cat)
(loopy (with (my-list '(0 1 2 3 4 5 6 7 8 9)))
       (seq-ref i my-list :from 1 :by 2 )
       (do (setf i 'cat))
       (finally-return my-list))

;; => "0123456a8a"
(loopy (with (my-str "0123456789"))
       (seq-ref i my-str :downto 6 :by 2 )
       (do (setf i ?a))
       (finally-return my-str))
@end lisp
@end table

@node Accumulation
@section Accumulation

Accumulation commands are used to accumulate or aggregate values into a
variable, such as creating a list of values or summing the elements in
a sequence.

If needed, you can refer to the same accumulation variable in multiple
accumulation commands.

@lisp
;; => (1 6 2 7 3 8)
(loopy (list i '(1 2 3))
       (collect coll i)
       (collect coll (+ i 5))
       (finally-return coll))
@end lisp

Like with other loop commands, variables created by accumulation commands
(such as @samp{coll} in the above example) are initialized to @code{nil} unless
stated otherwise.

@cindex accumulation destructuring
Similar to iteration commands, accumulation commands can also use
destructuring.  In accumulation commands, the values resulting from
destructuring are accumulated, instead of the destructured value.

@lisp
;; => ((1 4) (2 5) (3 6))
(loopy (list elem '((1 2 3) (4 5 6)))
       (collect (coll1 coll2 coll3) elem)
       (finally-return coll1 coll2 coll3))

;; => (5 7 9)
(loopy (list elem '((1 2 3) (4 5 6)))
       (sum (sum1 sum2 sum3) elem)
       (finally-return sum1 sum2 sum3))

;; Returns the same values as above.
(loopy (list elem '((1 2 3) (4 5 6)))
       (expr sum1 (cl-first elem)  (+ sum1 (cl-first elem)))
       (expr sum2 (cl-second elem) (+ sum2 (cl-second elem)))
       (expr sum3 (cl-third elem)  (+ sum3 (cl-third elem)))
       (finally-return sum1 sum2 sum3))
@end lisp


@cindex implied/implicit accumulation results
@vindex loopy-result
Like in @code{cl-loop}, you do not need to supply a variable name to accumulation
commands.  If no accumulation variable is given, accumulation commands will
use the variable @code{loopy-result}.  This variable is accessible in the
@samp{after-do}, @samp{finally-do}, and @samp{finally-return} special macro arguments.  You
should not attempt to modify this variable.  If you wish to override what
would be returned by the macro, simply use the @samp{finally-return} macro
argument as you normally would.

@lisp
;; => (1 2 3)
(cl-assert (equal (loopy (list i '(1 2 3))
                         (collect i)
                         (after-do (cl-return loopy-result)))

                  (loopy (list i '(1 2 3))
                         (collect i)
                         (finally-return loopy-result))))

;; => (0 1 2 3)
(cl-assert (equal (loopy (list i '(1 2 3))
                         (collect i)
                         (else-do (push 0 loopy-result)
                                  (cl-return loopy-result)))
                  (loopy (list i '(1 2 3))
                         (collect i)
                         (finally-do (push 0 loopy-result))
                         (finally-return loopy-result))))
@end lisp

@cindex implied/implicit return values
Using an accumulation command without naming a variable implies a return
value for the macro, which you can override using the @samp{return} and
@samp{return-from} loop commands or the @samp{finally-return} macro argument.  Be aware
that that explicitly named accumulation variables do not affect this implied
return value.  This limitation is needed for more consistently handling the
complexity that comes from allowing the use of Pcase's arbitrary
destructuring macros, and may change in the future.

@lisp
;; => (1 2 3)
(loopy (list i '(1 2 3))
       (collect i))

;; => (1 2 3)
(loopy (list i '(1 2 3))
       (collect i)
       (collect my-other-collection (* 2 i))
       (collect (a b) (list i (* 2 i))))
@end lisp

Therefore, when mixing implicit and explicit accumulation variables, you must
use the @samp{finally-return} special macro argument to return all of the
accumulation results.

@lisp
;; => ((1 2 3) (2 4 6) (1 2 3) (2 4 6))
(loopy (list i '(1 2 3))
       (collect i)
       (collect my-other-collection (* 2 i))
       (collect (a b) (list i (* 2 i)))
       (finally-return loopy-result
                       my-other-collection
                       a b))
@end lisp

Like in @code{cl-loop}, all accumulation commands using implied variables will
accumulate into the same implied variable (that is, into @code{loopy-result}).  An
error will be signaled if the accumulation commands are not compatible.  For
example, you should not try to accumulate @samp{collect} results and @samp{sum} results
into @code{loopy-result}, as trying to use a list as a number will cause an error.
If you want to collect into separate variables, just specify a variable name
like you normally would.

@lisp
;; => (3 2 1 11 12 13)
(loopy (nums i 1 3)
       (collect i :at start)
       (collect (+ i 10) :at end))
@end lisp

@quotation Warning
You should not try to access implied accumulation results (e.g.,
@code{loopy-result}) while the loop is running.  Implied results are only required
to be correct after the loop ends (before code in @samp{else-do} is run), allowing
for more efficient code.

Furthermore, because using a @samp{return} or @samp{return-from} command overrides
implied return values, using these commands can prevent implied accumulation
results from being finalized.  Using the @samp{leave} command, which exits the
loop without returning a value, does not affect the correctness of implied
results.

@end quotation

You should prefer using implied variables with accumulation commands whenever
you can.  If you do not need access to accumulation variables while the loop
is running, then there is no point in requesting that @code{loopy} generate code
to allow that possibility.  Because @code{loopy} has more freedom in working with
implied accumulation variables, their use can be much faster.

By default, one must specify accumulation variables in order to accumulate
into separate values.  As noted above, @code{loopy} will allow access to these
variables during the loop, which requires a reduction in speed.  To have
separate commands accumulate into separate variables while avoiding this
reduction, one can use the @samp{split} flag (@ref{Using Flags, , Flags}).

When the flag is enabled and after the loop completes, each of these split
accumulation variables will be part of the list @code{loopy-result}, appearing in
the same order as their respective commands in the macro's arguments.  In the
example below, note that the result of @code{(collect i)} is the first element of
@code{loopy-result}, even though the collection happens @emph{after} the first
summation when the loop runs.

@lisp
;; => ((2 4) 15)
(loopy (flag split)
       (nums i 1 5)
       (when (cl-evenp i)
         (collect i))
       (sum i)
       ;; This `finally-return' isn't needed, as `loopy-result'
       ;; is already the implied return value.
       (finally-return loopy-result))
@end lisp

Using this behavior can produce results much faster than destructuring
accumulation commands.

@lisp
;; Both of these example give the same result, but the latter can
;; expand into more efficient code.

;; => ((1 4) (2 5) (3 6))
(loopy (list elem '((1 2 3) (4 5 6)))
       (collect (i j k) elem)
       (finally-return i j k))

;; => ((1 4) (2 5) (3 6))
(loopy (flag split)
       (list (i j k) '((1 2 3) (4 5 6)))
       (collect i)   ; Without the `split' flag,
       (collect j)   ; this would just produce
       (collect k))  ; (1 2 3 4 5 6).
@end lisp

To be clear, the more guarantees that can be made about the accumulation
variables, the more @code{loopy} can optimize the accumulations.  The fastest
accumulations (from greatest speed to least), are produced by:
@enumerate
@item
Using implied result variables with the @samp{split} flag enabled.
@item
Using the implied variable @code{loopy-result}, which, similar to the variables
in (1), cannot be modified during the loop except by other accumulation
commands.  This is the default behavior for accumulation commands that do
not name a variable, and occurs when the @samp{split} flag is disabled.
@item
Using explicitly named result variables, which can be modified during the
loop by arbitrary code, not just accumulation commands.  This includes the
explicitly named variables required for destructuring.
@end enumerate

Effort has gone into making each case efficient while keeping flexibility and
correctness.  The difference in speed can be significant when working with
large sequences or performing many accumulations.

@lisp
;; This is the slowest form.
;; => (1 2 3)
(loopy (list i '(1 2 3))
       (collect my-collection i)
       (finally-return my-collection))

;; Accumulations with implicit variables are faster.
;; => (1 2 3)
(loopy (list i '(1 2 3))
       (collect i))

;; Accumulations with split implicit variables are fastest.
(loopy (flag split)
       (list i '(1 2 3))
       (collect i))
@end lisp

@cindex accumulation keyword arguments
Some accumulation commands have optional keyword parameters, which are listed
in the command's definition.  To avoid repetition, the common parameters are
all described below.

@cindex accumulation keyword at
@table @asis
@item @samp{at}
Where to place a value.  One of @samp{end}, @samp{start}, or @samp{beginning}
(equivalent to @samp{start}).  If ungiven, defaults to @samp{end}.  These positions
need not be quoted.
@end table
@cindex accumulation keyword into
@table @asis
@item @samp{into}
An alternative way to specify the variable into which to
accumulate values.  One would normally just give @samp{VAR} as the first
argument of the loop command, but if you wish, you can use this keyword
argument for a more @code{cl-loop}-like syntax.

As all accumulation commands support this keyword, it is not listed in
any command definition.
@end table
@cindex accumulation keyword test
@table @asis
@item @samp{test}
A function of two arguments, usually used to test for equality.
Most tests default to @code{eql}, as in Common Lisp and the @samp{cl-lib} library.
@end table
@cindex accumulation keyword key
@table @asis
@item @samp{key}
A function of one argument, used to transform the inputs of
@samp{test}.
@end table
@cindex accumulation keyword init
@table @asis
@item @samp{init}
The initial value of @samp{VAR}.  For explicitly named variables, one
can use this argument or the @samp{with} special macro argument.  When using the
@samp{split} flag, this argument is the only way to specify a non-default
initial value.
@end table
@cindex accumulation keyword result-type
@table @asis
@item @samp{result-type}
A sequence type into which @samp{VAR} is converted @emph{after the
loop is over}.  These types need not be quoted.  For example, @samp{'vector} and
@samp{vector} are both valid ways to specify the data type vector.

This argument can be more convenient than writing out a call to @code{cl-coerce}
or @code{seq-into}.
@end table

The arguments to the @samp{test} and @samp{key} parameters can be quoted functions or
variables, just like when using @code{cl-union}, @code{cl-adjoin}, and so on.  @code{loopy}
knows how to expand efficiently for either case.

@quotation Note
You will notice that each accumulation command has an alias of the command
name in the present participle form (the ``-ing'' form).

For example, instead of ``min'' or ``minimize'', you can use ``minning'' or
``minimizing''.  Instead of ``sum'' and ``append'', you can use ``summing'' and
``appending''.  This helps to avoid name collisions when using the @code{loopy-iter}
macro with the @samp{lax-naming} flag enabled (@ref{The @code{loopy-iter} Macro}).

@end quotation


The available accumulation commands are:

@findex accumulate
@table @asis
@item @samp{(accumulate|accumulating VAR EXPR FUNC &key init)}
Accumulate the
result of applying function @samp{FUNC} to @samp{EXPR} and @samp{VAR}.  @samp{EXPR} and @samp{VAR}
are used as the first and second arguments to @samp{FUNC}, respectively.

This is a generic command in case the others don't meet your needs.

This command is similar to the @samp{expr} command, except that this command
will not create variables local to loops made by the @samp{sub-loop} command.

@lisp
;; Call `(cons i my-accum)'
;;
;; => (2 1)
(loopy (list i '(1 2))
       (accumulate my-accum i #'cons :init nil)
       (finally-return my-accum))

;; Works mostly the same as the above:
(loopy (list i '(1 2))
       (expr my-accum (cons i my-accum))
       (finally-return my-accum))

;; => ((3 1) (4 2))
(loopy (list i '((1 2) (3 4)))
       (accumulate (accum1 accum2) i #'cons :init nil)
       (finally-return accum1 accum2))
@end lisp

This command also has the alias @samp{callf2}.  It is similar to using the
function @code{cl-callf2}, except that the function argument is given last and
must be quoted.  This alias is intended to help users remember argument
order.

@lisp
(loopy (list i '(1 2))
       (callf2 my-accum i #'cons :init nil)
       (finally-return my-accum))

;; Is the same as the above:
(loopy (with (my-accum))
       (list i '(1 2))
       (do (cl-callf2 cons i my-accum))
       (finally-return my-accum))
@end lisp
@end table

@findex adjoin
@table @asis
@item @samp{(adjoin|adjoining VAR EXPR &key at test key init result-type)}
Repeatedly
add @samp{EXPR} to @samp{VAR} if it is not already present in the list.

@lisp
;; Without a test, defaults to `eql' as in `cl-adjoin'.
;; => ((1 . 1) (1 . 2) (1 . 2) (2 . 3))
(loopy (list i '((1 . 1) (1 . 2) (1 . 2) (2 . 3)))
       (adjoin i))

;; Using `equal' for the test.
;; => ((1 . 1) (1 . 2) (2 . 3))
(loopy (list i '((1 . 1) (1 . 2) (1 . 2) (2 . 3)))
       (adjoin i :test #'equal))

;; Using `=' for the test and `car' for the key.  This
;; treats '(1 . 2) as equivalent to '(1 . 1), so it
;; won't be added.
;;
;; => ((1 . 1) (2 . 3))
(loopy (list i '((1 . 1) (1 . 2) (1 . 2) (2 . 3)))
       (adjoin i :test #'= :key #'car))

;; Coerced to a vector /after/ the loop ends.
;; => [1 2 3 4]
(loopy (list i '(1 2 3 3 4))
       (adjoin my-var i :result-type 'vector)
       (when (vectorp my-var)
         (return 'is-vector))
       (finally-return my-var))

;; => [4 3 2 1]
(loopy (list i '(1 2 3 3 4))
       (adjoin my-var i :result-type 'vector :at 'start)
       (finally-return my-var))
@end lisp
@end table

@findex append
@table @asis
@item @samp{(append|appending VAR EXPR &key at)}
Repeatedly concatenate @samp{EXPR} to
@samp{VAR}, as if by the function @code{append}.

@lisp
;; => '(1 2 3 4 5 6)
(loopy (list i '((1 2 3) (4 5 6)))
       (append coll i)
       (finally-return coll))

;; => (4 5 6 1 2 3)
(loopy (list i '((1 2 3) (4 5 6)))
       (append coll i :at start)
       (finally-return coll))
@end lisp
@end table

@findex collect
@table @asis
@item @samp{(collect|collecting VAR EXPR &key result-type at)}
Collect the value of
@samp{EXPR} into the list @samp{VAR}.  By default, elements are added to the end of the
list.

@lisp
;; => '(1 2 3)
(loopy (list i '(1 2 3))
       (collect i))

;; => '((1 2 3) ((1) (1 2) (1 2 3)))
(loopy (list i '(1 2 3))
       ;; Collect `i' into `coll1'.
       (collect coll1 i)
       ;; Collect `coll1' into a generated variable.
       (collect coll1)
       (finally-return coll1 loopy-result))

;; => [1 2 3]
(loopy (list j '(1 2 3))
       (collect j :result-type 'vector))

;; => (3 2 1)
(loopy (list j '(1 2 3))
       (collect j :at start))

;; => (1 2 3)
(loopy (list j '(1 2 3))
       (collect j :at 'end))
@end lisp
@end table

@findex concat
@table @asis
@item @samp{(concat|concating VAR EXPR &key at)}
Repeatedly @code{concat} the value of
@samp{EXPR} onto @samp{VAR}, as a string.  See the @samp{vconcat} command for
concatenating values into a vector.

Unlike when using the @samp{:result-type} keyword argument for some other
commands, @samp{VAR} is a string throughout the loop, not just after the loop
ends.

@lisp
;; => "abc"
(loopy (list i '("a" "b" "c"))
       (concat str i)
       (finally-return str))

;; => ("da" "eb" "fc")
(loopy (list j '(("a" "b" "c") ("d" "e" "f")))
       (concat (str1 str2 str3) j :at 'start)
       (finally-return str1 str2 str3))
@end lisp
@end table

@findex count
@table @asis
@item @samp{(count|counting VAR EXPR)}
Count the number of times that @samp{EXPR}
evaluates to a non-nil value.  @samp{VAR} starts at 0 and is incremented by 1
each time.

@lisp
;; => 3
(loopy (list i '(1 nil 3 nil 5))
       (count non-nil-count i)
       (finally-return non-nil-count))
@end lisp
@end table

@findex find, finding
@table @asis
@item @samp{(find|finding VAR EXPR TEST &key ON-FAILURE)}
If @samp{TEST} is
non-nil, the loop stops and @samp{EXPR} is used as a returned value.  If @samp{TEST}
is never non-nil, then @samp{ON-FAILURE} is used as a returned value, if
provided.

@samp{VAR} takes the value of @samp{EXPR} if @samp{TEST} is non-nil or @samp{ON-FAILURE} if the
loop completes successfully.  It is bound to @code{nil} during  the loop.  As
with other accumulation commands, if @samp{VAR} is provided, then @samp{EXPR} is not
used as a return value.  Instead, it is assigned to @samp{VAR}, which must be
returned explicitly.

@lisp
;; => 3
(loopy (list i '(1 2 3))
       (finding i (> i 2)))

;; => nil
(loopy (list i '(1 2 3))
       (finding i (> i 4)))

;; => "not found"
(loopy (list i '(1 2 3))
       (finding i (> i 4) :on-failure "not found"))

;; => 2
;; Does not display message.
(loopy (list i '(1 2 3))
       (finding i (= i 2) :into found)
       (after-do (message "found: %s" found))
       (finally-return found))

;; => 2
;; Messages "found: 2" in echo area.
(loopy (list i '(1 2 3))
       (finding found i (= i 2))
       (finally-do (message "found: %s" found))
       (finally-return found))

;; => "not found"
(loopy (list i '(1 2 3))
       (finding whether-found i (> i 4) :on-failure "not found")
       (finally-return whether-found))
@end lisp
@end table

@findex max, maximize
@table @asis
@item @samp{(max|maxing|maximize|maximizing VAR EXPR)}
Repeatedly set @samp{VAR} to the
greater of @samp{VAR} and the value of @samp{EXPR}.  @samp{VAR} starts at @samp{-1.0e+INF}, so
that any other value should be greater that it.

@lisp
;; => 11
(loopy (list i '(1 11 2 10 3 9 4 8 5 7 6))
       (max my-max i)
       (finally-return my-max))
@end lisp
@end table

@findex min, minimize
@table @asis
@item @samp{(min|minning|minimize|minimizing VAR EXPR)}
Repeatedly set @samp{VAR} to the
lesser of @samp{VAR} and the value of @samp{EXPR}.  @samp{VAR} starts at @samp{1.0e+INF}, so
that any other value should be less than it.

@lisp
;; => 0
(loopy (list i '(1 11 2 10 3 0 9 4 8 5 7 6))
       (min my-min i)
       (finally-return my-min))
@end lisp
@end table

@findex multiply, multiplying
@table @asis
@item @samp{(multiply|multiplying VAR EXPR)}
Repeatedly set @samp{VAR} to the product of
the values of @samp{EXPR}.  @samp{VAR} starts at 1.

@lisp
;; => 120
(loopy (list i '(1 2 3 4 5))
       (multiply 5-factorial i)
       (finally-return 5-factorial))
@end lisp
@end table

@findex nconc
@table @asis
@item @samp{(nconc|nconcing VAR EXPR &key at)}
Repeatedly concatenate the value of
@samp{EXPR} onto @samp{VAR} as if via the function @code{nconc}.

@quotation Caution
@code{nconc} is a destructive operation that modifies @samp{VAR} directly
(@ref{Rearrangement,,,elisp,}).  This is important to keep in mind when working
with literal values, such as the list @samp{'(1 2 3)}, whose modification could
apply wherever that value is used (@ref{Self-Evaluating Forms,,,elisp,}).

@end quotation

@lisp
;; => '(1 2 3 4 5 6 7 8)
(loopy (list i '((1 2 3 4) (5 6 7 8)))
       (nconc my-new-list i)
       (finally-return my-new-list))

;; => '(3 3 3 2 2 1)
(loopy (list i (list (make-list 1 1)
                     (make-list 2 2)
                     (make-list 3 3)))
       (nconc i :at start))
@end lisp
@end table

@findex nunion
@table @asis
@item @samp{(nunion|nunioning VAR EXPR &key test key at)}
Repeatedly and
@emph{destructively} insert into @samp{VAR} the elements of @samp{EXPR} which are not
already present in @samp{VAR}.

@lisp
;; => (4 1 2 3)
(loopy (list i '((1 2) (2 3) (3 4)))
       (nunion var i)
       (finally-return var))

;; => ((a . 2))
(loopy (array i [((a . 1)) ((a . 2))])
       (nunioning var i :key #'car)
       (finally-return var))

;; => (4 2 (1 1) 3)
(loopy (list i '(((1 1) 2) ((1 1) 3) (3 4)))
       (nunioning var i :test #'equal)
       (finally-return var))

;; => ((1 2 3) (2 3 4))
(loopy (array i [((1 2) (2 3))
                 ((1 2 3) (3 4))])
       (nunion (var1 var2) i :test #'equal)
       (finally-return var1 var2))

;; => ((4 2) (1 2) (3 2))
(loopy (list i '(((1 2) (3 2)) ((1 1) (4 2))))
       (nunion i :at start :key #'car))
@end lisp
@end table

@findex prepend
@table @asis
@item @samp{(prepend|prepending VAR EXPR)}
Repeatedly concatenate @samp{EXPR} onto the
front of @samp{VAR}.

This command is equivalent to @samp{(append VAR EXPR :at start)}.  It exists
for clarity and convenience.

@lisp
;; => (5 6 3 4 1 2)
(loopy (array i [(1 2) (3 4) (5 6)])
       (prepend i))

;; => (4 3 2 1)
(let ((my-list '(1)))
  (loopy (without my-list)
         (array elem [(2) (3) (4)])
         (prepend my-list elem)
         (finally-return my-list)))
@end lisp
@end table

@findex push, push-into
@table @asis
@item @samp{(push|push-into|pushing|pushing-into VAR EXPR)}
Collect the value of
@samp{EXPR} into a list, adding values to the front of @samp{VAR} as if via the
function @code{push}.

This command is equivalent to @samp{(collect VAR EXPR :at start)}.  It exists
for clarity and convenience.

@lisp
;; => (3 2 1)
(loopy (array i [1 2 3])
       (push my-list i)
       (finally-return my-list))
@end lisp
@end table

@findex reduce
@table @asis
@item @samp{(reduce|reducing VAR EXPR FUNC &key init)}
Reduce @samp{EXPR} into @samp{VAR} via
@samp{FUNC}.  @samp{FUNC} is called with @samp{VAR} as the first argument and @samp{EXPR} as
the second argument.  This is unlike @samp{accumulate}, which gives @samp{VAR} and
@samp{EXPR} to @samp{FUNC} in the opposite order (i.e., @samp{EXPR} first, then @samp{VAR}).

@samp{VAR} is initialized to @samp{INIT}, if provided, or @code{nil}.

This command is similar to the @samp{expr} command, except that this command
will not create variables local to loops made by the @samp{sub-loop} command.

@lisp
;; = > 6
(loopy (list i '(1 2 3))
       (reduce my-reduction i #'+ :init 0)
       (finally-return my-reduction))

;; Works similarly to above:
(loopy (list i '(1 2 3))
       (expr my-reduction (+ i my-reduction) :init 0)
       (finally-return my-reduction))

;; => 24
(loopy (list i '(1 2 3 4))
       (reduce i #'* :init 1))
@end lisp

This command also has the alias @samp{callf}.  It is similar to using the
function @code{cl-callf}, except that the function argument is given last and
must be quoted.  This alias is intended to help users remember argument
order.

@lisp
(loopy (list i '(1 2 3))
       (callf my-reduction i #'+ :init 0)
       (finally-return my-reduction))

;; Is similar to the above:
(loopy (with (my-reduction 0))
       (list i '(1 2 3))
       (do (cl-callf + my-reduction i))
       (finally-return my-reduction))
@end lisp
@end table

@findex sum
@table @asis
@item @samp{(sum|summing VAR EXPR)}
Repeatedly set @samp{VAR} to the sum of the values
of @samp{EXPR} and @samp{VAR}.  @samp{VAR} starts at 0.

@lisp
;; => 10
(loopy (list i '(1 2 3 4))
       (sum my-sum i)
       (finally-return my-sum))
@end lisp
@end table

@findex union
@table @asis
@item @samp{(union|unioning VAR EXPR &key test key at)}
Repeatedly insert into @samp{VAR}
the elements of the list @samp{EXPR} which are not already present in @samp{VAR}.

@lisp
;; => (4 1 2 3)
(loopy (list i '((1 2) (2 3) (3 4)))
       (union var i)
       (finally-return var))

;; => ((a . 2))
(loopy (array i [((a . 1)) ((a . 2))])
       (unioning var i :key #'car)
       (finally-return var))

;; => (4 2 (1 1) 3)
(loopy (list i '(((1 1) 2) ((1 1) 3) (3 4)))
       (unioning var i :test #'equal)
       (finally-return var))

;; => ((1 2 3) (2 3 4))
(loopy (array i [((1 2) (2 3))
                 ((1 2 3) (3 4))])
       (union (var1 var2) i :test #'=)
       (finally-return var1 var2))

;; => ((4 2) (1 2) (3 2))
(loopy (list i '(((1 2) (3 2)) ((1 1) (4 2))))
       (union var i :at 'start :key #'car)
       (finally-return var))
@end lisp
@end table

@findex vconcat
@table @asis
@item @samp{(vconcat|vconcating VAR EXPR)}
Repeatedly concatenate the value of
@samp{EXPR} onto @samp{VAR} via the function @code{vconcat}.

Unlike when using the @samp{:result-type} keyword argument for some other
commands, @samp{VAR} is a vector throughout the loop, not just after the loop
ends.

@lisp
;; => [1 2 3 4 5 6]
(loopy (list i '([1 2 3] [4 5 6]))
       (vconcat my-vector i)
       (finally-return my-vector))

;; => [4 5 6 1 2 3]
(loopy (list i '([1 2 3] [4 5 6]))
       (vconcat i :at 'start))
@end lisp

To concatenate values as strings, see the command @samp{concat} above.
@end table

@node Boolean
@section Boolean

Boolean commands are used to test whether a condition holds true for elements
of a sequence.  Under certain conditions, they cause the loop to exit and
return a value.  Like accumulation commands, they have an implicit return
value which is used if these commands do not cause the loop to exit.

It is incorrect to use both @samp{thereis} and one of @samp{always} or @samp{never} in the
same loop, as this leads to conflicting implicit return values.

For convenience, these commands can be passed multiple conditions.

@findex always
@table @asis
@item @samp{(always COND [CONDS])}
Immediately return @code{nil} if any @samp{COND} is ever
@code{nil}.  Otherwise, the loop returns the final value of the last @samp{COND} or
@code{t} if no @samp{COND} is ever evaluated.

@lisp
;; => t
(loopy (list i '(1 0 1 0 1))
       (always (< i 2)))

;; => nil
(loopy (list i '(1 0 1 0 1))
       (always (< i 1)))

;; => t
(loopy (list i '(1 0 1 0 1))
       ;; Note: can accept multiple conditions.
       ;; This is equivalent to `(always (and (< i 2) (>= i 0)))'.
       (always (< i 2) (>= i 0)))

;; => "hello"
(loopy (list i '(1 1 1 1))
       ;; The return value of `(and (< i 2) "hello")' is "hello".
       (always (< i 2) "hello"))

;; NOTE: Here, the implicit return value is `t' because an
;;       `always' command was used, and that return value
;;       is never updated to "hello" because the `always'
;;       command is never actually used.
;;
;; => t
(loopy (list i '(1 1 1 1))
       (when nil
         (always (> i 5) "hello")))
@end lisp
@end table

@findex never
@table @asis
@item @samp{(never COND [CONDS])}
Immediately return @code{nil} if any @samp{COND} is ever
non-nil.  Otherwise, the loop returns @code{t}.

@lisp
;; => t
(loopy (list i '(1 0 1 0 1))
       (never (= i 3)))

;; => nil
(loopy (list i '(1 0 1 0 1))
       (never (= i 0)))

;; Like `always', `never' can also accept multiple arguments. They are
;; treated as `(never (or COND1 COND2 ... CONDN))'.

;; => t
(loopy (list i '(1 0 1 0 1))
       ;; equivalent to `(never (or (= i 3) (= i 4)))'.
       (never (= i 3) (= i 4)))
@end lisp

@samp{never} does not affect the loop's implicit return value when using the
@samp{always} command.

@lisp
;; This example taken from the documentation of CL's Iterate package.
;;
;; => 2, not t
(loopy (repeat 2)
       (always 2)
       (never nil))
@end lisp
@end table

@findex thereis
@table @asis
@item @samp{(thereis COND [CONDS])}
Immediately return the value of @samp{COND} if said
value is ever non-nil.  Otherwise, the loop returns @code{nil}.  If more than
one condition is specified, then they are treated as one condition joined
by @code{and}.

@lisp
;; => 3
(loopy (list i '(1 0 1 3 1))
       ;; Note: `and' returns the last value it evaluates.
       (thereis (and (> i 2) i)))

;; => nil
(loopy (list i '(1 0 1 0 1))
       (thereis (and (> i 2) i)))

;; => nil
(loopy (list i '(1 0 1 0 1))
       ;; Same as above. Like `always' uses an explicit `and'.
       (thereis (> i 2) i))

;; => 3
(loopy (list i '(nil nil 3 nil))
       (thereis i))
@end lisp
@end table

@node Control Flow
@section Control Flow

@menu
* Conditionals::                 Choosing if commands should run.
* Skipping Cycles::              Immediately beginning the next iteration.
* Early Exit::                   Leaving the loop early, with or without returning values.
@end menu

@node Conditionals
@subsection Conditionals

Conditional commands in @code{loopy} can take multiple sub-commands, and work
like their Lisp counterparts.  There is therefore no need for an @samp{and}
command as used in @code{cl-loop}.

@findex when
@table @asis
@item @samp{(when EXPR CMDS)}
Run @samp{CMDS} only if @samp{EXPR} is non-nil.

@lisp
;; Get only the inner lists with all even numbers.
;; => '((2 4 6) (8 10 12) (16 18 20))
(loopy (list i '((2 4 6) (8 10 12) (13 14 15) (16 18 20)))
       (when (loopy (list j i)
                    (when (cl-oddp j)
                      (return nil))
                    (else-do (cl-return t)))
         (collect only-evens i))
       (finally-return only-evens))
@end lisp
@end table

@findex if
@table @asis
@item @samp{(if EXPR CMDS)}
Run the first command if @samp{EXPR} is non-nil.
Otherwise, run the remaining commands.

@lisp
;; => '((7 5 3 1) (6 4 2) (3 3 3))
(loopy (seq i [1 2 3 4 5 6 7])
       (if (cl-oddp i)
           (push-into reversed-odds i)
         (push-into reversed-evens i)
         (push-into some-threes 3))
       (finally-return reversed-odds
                       reversed-evens
                       some-threes))
@end lisp
@end table

@findex cond
@table @asis
@item @samp{(cond [(EXPR CMDS) [...]])}
For the first @samp{EXPR} to evaluate to
non-nil, run the following commands @samp{CMDS}.

@lisp
;; => '((2 4 6) (1 3 5) ("cat" "dog"))
(loopy (list i '(1 2 3 "cat" 4 5 6 "dog"))
       (cond
        ((not (numberp i)) (collect not-numbers i))
        ((cl-evenp i)      (collect evens i))
        (t                 (collect odds i)))
       (finally-return evens odds not-numbers))
@end lisp
@end table

@node Skipping Cycles
@subsection Skipping Cycles

@findex skip, continue
@table @asis
@item @samp{(skip|continue)}
Go to next loop iteration.

@lisp
;; => (2 4 6 8 12 14 16 18)
(loopy (seq i (number-sequence 1 20))
       (when (zerop (mod i 10))
         (skip))
       (when (cl-evenp i)
         (push-into my-collection i))
       (finally-return (nreverse my-collection)))
@end lisp
@end table

@node Early Exit
@subsection Early Exit

The loop is contained in a @code{cl-block}, which can be exited by the function
@code{cl-return-from}.  Indeed, the @samp{return} and @samp{return-from} commands just are
wrappers around that function.

If multiple values are passed to @samp{return} or @samp{return-from}, these commands
will return a list of those values.  If no value is given, @code{nil} is
returned.

The commands @samp{leave}, @samp{while}, and @samp{until} leave the current loop without
forcing a returned value.  Unlike the @samp{return} commands, they do not stop
the loop from returning implied return values, such as the collection in
their respective examples.

@findex leave
@table @asis
@item @samp{leave}
Leave the current loop without forcing a return value.

@lisp
;; => (1 2 3 4)
(loopy (list i '(1 2 3 4 5 6 7))
       (if (= i 5)
           (leave)
         (collect i)))
@end lisp
@end table

@findex return loop command
@table @asis
@item @samp{(return [EXPRS])}
Leave the current loop, returning @samp{[EXPRS]}.

@lisp
(loopy (with  (j 0))
       (do (cl-incf j))
       (when (> j 5)
         (return j))) ; => 6
@end lisp
@end table

@findex return-from
@table @asis
@item @samp{(return-from NAME [EXPRS])}
Leave the loop @samp{NAME}, returning @samp{[EXPRS]}.

@lisp
;; => 'bad-val?
(loopy outer-loop
       (list inner-list '((1 2 3) (1 bad-val? 1) (4 5 6)))
       (do (loopy (list i inner-list)
                  (when (eq i 'bad-val?)
                    (return-from outer-loop 'bad-val?)))))
@end lisp
@end table

@findex while
@table @asis
@item @samp{(while COND)}
Leave the loop once @samp{COND} is false, without forcing a
return value.

@lisp
;; => (1 2 3 4)
(loopy (list i '(1 2 3 4 5 6 7))
       (while (not (= i 5)))
       (collect i))
@end lisp
@end table

@findex until
@table @asis
@item @samp{(until COND)}
Leave the loop once @samp{COND} is true, without forcing a
return value.

@lisp
;; => (1 2 3 4)
(loopy (list i '(1 2 3 4 5 6 7))
       (until (= i 5))
       (collect i))
@end lisp
@end table

@node Sub-loops
@section Sub-loops

@findex sub-loop, subloop, loop
@table @asis
@item @samp{(sub-loop|subloop|loop [CMDS])}
Create a sub-loop in the same lexical
environment as the top-level loop.
@end table


There are two main ways to have a sub-loop in @code{loopy}:

@enumerate
@item
Use another @code{loopy} call in a @samp{do} command.
@item
Use the @samp{sub-loop} (aliases @samp{loop} and @samp{subloop}) command.
@end enumerate

@samp{sub-loop} is better for accumulating into variables, as is does not create
its own result variable (unlike calling @code{loopy} again).  When using the
@samp{sub-loop} command, keep in mind the following:

@enumerate
@item
Only loop commands are valid within a sub-loop, not special macro
arguments like @samp{with} or @samp{finally-return}.

@lisp
;; GOOD:
;; => (8 9 10)
(loopy (with (a 7))
       (repeat 1)
       (loop (list i '(1 2 3))
             (collect (+ a i))))

;; BAD:
(loopy (repeat 1)
       (loop (with (a 7))
             (list i '(1 2 3))
             (collect (+ a i))))
@end lisp

@item
Sub-loops can be named, but they do not have their own return value. The
default loop name in @code{loopy} is @code{nil} for the top-level loop, but not for
sub-loops.  To return from the outer loop, you can use @samp{return-from}.

@lisp
;; Return from inner1 so never reach 4.
;; => ((3 5) (3 5))
(loopy (repeat 2)
       (loop inner1
             (list j '(3 4))
             (loop (list k '(5 6 7))
                   (if (= k 6)
                       (return-from inner1)
                     (collect (list j k))))))

;; Can use `return-from' on `nil' to refer to the
;; top-level loop, if un-named. Otherwise use the name.
(loopy (list i '(1 2 3))
       (loop (list j '(5 4 3))
             (if (= i j)
                 (return-from nil i)
               (collect (cons i j)))))
@end lisp

Because there is no return value for sub-loops, the @samp{return} and @samp{leave}
commands behave similarly.

@lisp
;; => ((1 .6) (2 . 6))
(loopy (list i '(1 2))
       (loop (list j '(6 7 8))
             (if (= j 7)
                 (return)
               (collect (cons i j)))))

;; => ((1 .6) (2 . 6))
(loopy (list i '(1 2))
       (loop (list j '(6 7 8))
             (if (= j 7)
                 (leave)
               (collect (cons i j)))))
@end lisp

@item
Variables used for iteration can be local to a sub-loop, but not
variables used for accumulation.

@lisp
;; GOOD:
;; => (0 1 2 3 1 2 3)
(loopy (repeat 2)
       (loop (list i '(1 2 3))
             (collect my-coll i))
       (finally-return (cons 0 my-coll)))

;; BAD:
;; Would not give (0 3 3).  Instead, signals error.
(loopy (repeat 2)
       (loop (list i '(1 2 3)))
       ;; Error:  `i' doesn't exist outside the sub-loop:
       (collect my-coll i)
       (finally-return (cons 0 my-coll)))
@end lisp
@end enumerate

@node Special Variables
@chapter Special Variables

Beyond loop commands, there is one special variable that can be used inside of
the loop.

@vindex loopy-first-iteration
@table @asis
@item @samp{loopy-first-iteration}
Whether the current loop is in its first
iteration.

@quotation Warning
You should not attempt to set this variable, as it is used by some loop
commands.

@end quotation
@end table

@node Destructuring Macros
@chapter Destructuring Macros

Loopy's built-in destructuring functionality can also be used via the macros
@code{loopy-let*}, @code{loopy-setq}, and @code{loopy-ref}.  These macros are @emph{not} affected
by flags which configure destructuring (@ref{Using Flags}), as equivalent macros are
already provided by those libraries.

These macros can be used anywhere, not just inside calls to @code{loopy}.

@findex loopy-let*
@table @asis
@item @code{loopy-let*}
Use destructuring in a @code{let} form, similar to @code{pcase-let}
and @code{seq-let}.

@lisp
;; => (1 2 3 4 5 28)
(loopy-let* ((a 1)
             ([b c] [2 3])
             ((&keys k1 k2 (k3 28)) '(:k1 4 :k2 5)))
  (list a b c k1 k2 k3))
@end lisp
@end table

@findex loopy-setq
@table @asis
@item @code{loopy-setq}
Use destructuring in a @code{setq} form.

@lisp
;; => (1 2 3 4 5 28)
(let (a b c k1 k2 k3)
  (loopy-setq a 1
              [b c] [2 3]
              (&keys k1 k2 (k3 28)) '(:k1 4 :k2 5))
  (list a b c k1 k2 k3))
@end lisp
@end table

@findex loopy-ref
@table @asis
@item @code{loopy-ref}
Create destructured references to the fields in a sequence
via @code{cl-symbol-macrolet}.  This is not to be confused with @code{cl-letf}, which
temporarily binds those places to a value.

This macro exposes the destructuring used in the sequence reference
iteration commands (@ref{Sequence Reference Iteration}).  There are some
limitations to this functionality in Emacs Lisp, which are described in that
section.

@lisp
;; => ((20 2 23) [24 25 26])
(let ((l1 (list 1 2 3))
      (a1 (vector 4 5 6)))
  (loopy-ref (((a _ b) l1)
              ([c &rest d] a1))
    (setf a 20
          b 23
          c 24
          d [25 26]))
  (list l1 a1))
@end lisp
@end table

@node The @code{loopy-iter} Macro
@chapter The @code{loopy-iter} Macro

@cindex loopy-iter
@findex loopy-iter
@code{loopy-iter} is a macro that allows for the embedding of loop commands inside
arbitrary code, instead of trying to use the @samp{do} loop command to embed
arbitrary code in a loop.  You must use @code{require} to load this feature.

@quotation Warning
@strong{This feature is still experimental.}  It might not work correctly in all
circumstances.

@end quotation

This macro is meant to be conceptually similar to the @code{iterate} or @code{iter}
macro provided by the Common Lisp package ``Iterate'' @footnote{@uref{https://common-lisp.net/project/iterate/}} (not to be
confused with the @code{iter-*} functions provided by Emacs).

@lisp
(require 'loopy-iter) ; <- Must `require' to load feature.

;; => (2 4 6)
(loopy-iter (for list i '(1 2 3))
            (let ((a (* 2 i)))
              (accum collect a)))
@end lisp

@cindex loopy-iter keywords
@vindex loopy-iter-command-keywords
To clearly distinguish between loop commands and Emacs features (such as the
loop command @samp{list} and the function @code{list}), a loop command must be preceded
by one of the keywords @samp{for}, @samp{accum}, or @samp{exit}.  These keywords do not share
a name with any built-in Emacs feature and are similar to the keywords used by
other packages.  For example, @samp{(list VAR LIST)} would be @samp{(for list VAR LIST)}
or @samp{(for in VAR LIST)}.

Any keyword in the user option @code{loopy-iter-command-keywords} can be used to
identify any loop command.  For example, @samp{(accum collect a)} and
@samp{(for collect a)} are both valid ways of referring to the @samp{collect} loop
command in @code{loopy-iter}.

To disable this requirement, use the flag @samp{lax-naming} (@ref{Using Flags}).  When
using @samp{lax-naming}, @code{loopy-iter} will always prefer built-in features to loop
commands.  For example, ``list'' will always be understood as referring to the
function @code{list} and not the loop command @samp{list}.

@vindex loopy-iter-ignored-commands
If for some reason you wish for @code{loopy-iter} to ignore a loop command while
using @samp{lax-naming}, you can add that symbol to @code{loopy-iter-ignored-commands}.

Special macro arguments, already having clearly distinguishable names, do not
need to be preceded by one of the above keywords.  However, some aliases (such
as @samp{let*} for @samp{with}) will not work in @code{loopy-iter}.

@lisp
;; => ((1 8) (2 9) (3 10))
(loopy-iter (with (a 7))                ; <- Set once around loop.
            (for list elem '(1 2 3))
            (let* ((c elem)             ; <- These set inside of loop.
                   (d (+ a c)))
              (accum collect (list c d))))
@end lisp

Restrictions on the placement of loop commands and special macro arguments
still apply in @code{loopy-iter}.  For example, iteration commands must still occur
at the top level of @code{loopy-iter} or a sub-loop.

@lisp
;; BAD
(loopy-iter (let ((a (progn
                       ;; ERROR: `list' must occur at top level.
                       (for list j '(8 9 10 11 12))
                       j)))
              (accum collect a)))

;; GOOD
;; => (8 9 10 11 12)
(loopy-iter (let ((a (progn
                       ;; NOTE: No restriction on placement of `expr'.
                       (for expr j 8 (1+ j))
                       (when (> j 12)
                         ;; Leave loop but don't force return value,
                         ;; allowing implicit result to be returned.
                         (exit leave))
                       j)))
              (accum collect a)))
@end lisp

You should not rely on the values of the code into which loop commands
translate.  For example, the above usage of @samp{expr} might become a @code{setq} form,
but that is an implementation detail and subject to change.  Best practice is
to instead use a variable as the last expression in a @code{progn} form.

For convenience, @code{loopy-iter} will not attempt to interpret loop commands in
quoted code, except in sharp-quoted @code{lambda} forms.  This is because the
@code{lambda} macro is self-quoting, and so Emacs might quote the form before it is
seen by @code{loopy-iter}.

@lisp
;; => (1 2 3)
(loopy-iter (for list elem '(1 2 3))
            (funcall (lambda (x)
                       (accum collect x))
                     elem))

;; => (1 2 3)
(loopy-iter (for list elem '(1 2 3))
            (funcall #'(lambda (x) ; <- sharp-quoted, but still interpreted
                         (accum collect x))
                     elem))
@end lisp

@quotation Note
Nesting arbitrary code in the loop requires knowing how to understand the
code.  You might find cases where @code{loopy-iter} interprets code incorrectly.

Please report such cases on this project's @uref{https://github.com/okamsn/loopy/issues, issues tracker}.

@end quotation

@code{loopy} (and so @code{loopy-iter}) does not currently have all of the features of
Common Lisp's @code{iter} macro.  Think of it more as a way to use loop commands
embedded in arbitrary code.

@node Using Flags
@chapter Using Flags

@cindex flag
A ``flag'' is a symbol passed to the @samp{flag} or @samp{flags} special macro argument,
and changes the macro's behavior.  Currently, flags affect what @code{loopy} uses
to perform destructuring (@code{pcase-let}, @code{seq-let}, @samp{dash}, or the default
method) and whether accumulation commands that don't specify a variable (such
as @samp{(collect collect-value)}) accumulate into one or several variables.

Flags are applied in order, so if you specify @samp{(flags seq pcase)} @code{loopy} will
use @code{pcase-let} for destructuring, not @code{seq-let}.

@vindex loopy-default-flags
If you wish to always use a flag, you can add that flag to the list
@code{loopy-default-flags}.  These can be overridden by any flag given in the
@samp{flag} special macro argument.

The following flags are currently supported:

@cindex pcase flag
@table @asis
@item @samp{pcase}
Use @code{pcase-let} for destructuring
(@ref{Destructuring with pcase Patterns,,,elisp,}).
@end table
@cindex seq flag
@table @asis
@item @samp{seq}
Use @code{seq-let} for destructuring (@ref{seq-let,,,elisp,}).
@end table
@cindex dash flag
@table @asis
@item @samp{dash}
Use the style of destructuring found in the @samp{dash} library
(@ref{-let,,,dash,}).
@end table
@cindex split flag
@table @asis
@item @samp{split}
Make accumulation commands with implicit variables accumulate into
separate variables which are then collected into @code{loopy-result}.
@end table
@cindex lax-naming flag
@table @asis
@item @samp{lax-naming}
In @code{loopy-iter}, don't require keywords when using loop
commands (@ref{The @code{loopy-iter} Macro}).
@end table
@cindex default flag
@table @asis
@item @samp{default}
Use the default behavior for all options.
@end table


For convenience, all flags (except @samp{default}) can be undone by prefixing them
with @samp{-} (a dash or minus sign), which reverts @code{loopy} to its default
behavior.

For example, if you have set @code{loopy-default-flags} to @samp{(dash split)} and wish
to only use the @samp{split} flag for a loop, you can use either @samp{(flags default
  split)} or, more simply, @samp{(flag -dash)}.  These prefixed flags only apply when
the unprefixed version is active.  That is, @samp{(flags pcase -dash)} is the same
as just @samp{(flags pcase)}, regardless of the value of @code{loopy-default-flags}, as
@samp{pcase} destructuring will override all uses of @samp{dash} destructuring as it
comes later in the list.  Similarly, @samp{(flags -dash dash)} and @samp{(flags -dash
  +dash)} leave @samp{dash} destructuring enabled, and @samp{(flags +dash -dash)} disables
@samp{dash} destructuring and uses the default behavior.

@cindex loopy-dash
@cindex loopy-pcase
@cindex loopy-seq
The destructuring flags (@samp{pcase}, @samp{seq}, and @samp{dash}) are separate libraries
(respectively, @samp{loopy-pcase}, @samp{loopy-seq}, and @samp{loopy-dash}) that must be
loaded after @samp{loopy}.  Currently, @samp{loopy-dash} is a separate package.

Below are some example of using the destructuring flags.  These flags affect
the destructuring of:
@itemize
@item
iteration variables
@item
accumulation variables
@item
variables bound by the special macro argument @samp{with}
@end itemize

@quotation Note
These flags do not affect the destructuring of generalized variables
(@code{setf}-able places) as the libraries @samp{pcase.el}, @samp{seq.el}, and @samp{dash.el} do
not yet provide the required functionality.

@end quotation

@lisp
;; => ((1 4)            coll1
;;     ((2 3) (5 6))    whole
;;     (2 5)            x
;;     (3 6))           y
(require 'loopy-dash)
(loopy (flag dash)
       (list (i j) '((1 (2 3)) (4 (5 6))))
       (collect coll1 i)
       (collect (whole &as x y) j)
       (finally-return coll1 whole x y))

;; => ((1 4) (3 6) 10 20 nil nil)
(require 'loopy-pcase)
(loopy (flag pcase)
       (with ((or `[,v1 ,v2] `(,v3 ,v4))
              [10 20]))
       (list elem '((1 (2 3)) (4 (5 6))))
       (collect `(,a (,_ ,b)) elem)
       (finally-return a b v1 v2 v3 v4))

;; => (14 26)
(require 'loopy-seq)
(loopy (flag seq)
       (with ([v1 v2] [10 20]))
       (list (i &rest j) '((1 . 2) (3 . 4)))
       (sum sum1 i)
       (sum sum2 j)
       (finally-return (+ sum1 v1) (+ sum2 v2)))
@end lisp

As noted in previous sections, the @samp{split} flag can be used to generate more
efficient code for accumulation commands (@ref{Accumulation}).  By making
stronger guarantees about how accumulation variables can be used, @code{loopy} can
produce results fasters.

@lisp
;; Both of these example give the same result, but the latter
;; can expand into more efficient code.
;;
;; There is also the `push-into' command, which avoids this problem when
;; used with `nreverse'.

;; => ((1 4) (2 5) (3 6))
(loopy (list elem '((1 2 3) (4 5 6)))
       (collect (i j k) elem)
       (finally-return i j k))

;; => ((1 4) (2 5) (3 6))
(loopy (flag split) ; Don't accumulate into same implicit variable.
       (list (i j k) '((1 2 3) (4 5 6)))
       (collect i)
       (collect j)
       (collect k))
@end lisp

Below is an example of the @samp{split} flag.

@lisp
;; => (1 2 3 4 5)
(loopy (flag -split)
       (list i '(1 2 3 4 5))
       (if (cl-oddp i)
           (collect i)
         (collect i))
       ;; This `finally-return' is unneeded.
       (finally-return loopy-result))

;; => ((1 3 5) (2 4))
(loopy (flag split)
       (list i '(1 2 3 4 5))
       (if (cl-oddp i)
           (collect i)
         (collect i))
       ;; This `finally-return' is unneeded.
       (finally-return loopy-result))
@end lisp

@node Custom Aliases
@chapter Custom Aliases

@cindex custom aliases
An @dfn{alias} is another name for a command.  @code{loopy} comes with several
built-in aliases, such as @samp{set} for the command @samp{expr}.

@vindex loopy-command-aliases
@findex loopy-defalias
Custom aliases can be added to the user option @code{loopy-command-aliases}, which
associates aliases with their true names.  For convenience, the macro
@code{loopy-defalias} is provided, which will correctly add an association to
this variable.

@lisp
;; You don't need to quote either argument,
;; but you can if you prefer.
(loopy-defalias l list)
(loopy-defalias a 'array)

;; => ((1 . 4) (2 . 5) (3 . 6))
(loopy (l i '(1 2 3))
       (a j [4 5 6])
       (collect (cons i j)))

;; => ((a . array) (l . list))
loopy-command-aliases
@end lisp

When looking for a command parser, @samp{loopy} will always check whether a given
name is an alias before checking whether it is a command.  Additionally,
aliases can be recursive.  That is, you can create a new alias for an existing
alias.

Special macro arguments (@ref{Special Macro Arguments}) can also be aliased.  Using
an alias does not change that the special macro arguments are parsed before
loop commands.

@lisp
(loopy-defalias as with)

;; => (8 9 10)
(loopy (as (a 7))
       (list i '(1 2 3))
       (collect (+ i 7)))
@end lisp

@node Custom Commands
@chapter Custom Commands

This section contains information about how loop commands work and how one can
add custom commands to @code{loopy}.  Two examples are provided.

@menu
* Background Info::              The internals of `loopy'.
* Hello World::                  A minimal working example.
* An @code{always} Command::     Adding a feature from `cl-loop'.
* Finding More Examples::
@end menu

@node Background Info
@section Background Info

@cindex instruction, instructions
The core working of @code{loopy} is taking a loop command and generating code that
becomes part of a @code{while}-loop.  This code is represented by
@dfn{instructions}, which basically describe where and how code is
inserted into/around a template of a @code{while}-loop.

Some examples of instructions are:
@itemize
@item
Declaring a given variable in a let form to make sure it's locally
scoped.
@item
Declaring a generated variable in a let form to contain a given value.
@item
Adding a condition for continuing/exiting the loop.
@item
Adding code to be run during the main processing section of the
@code{while}-loop.  This location is referred to as the @dfn{main body} of
the loop.
@item
Adding code to be run after the main processing section, such as for
updating variables.  This location is referred to as the @dfn{latter body} of the loop.
@end itemize

For example, parsing the command @samp{(list i '(1 2 3))} produces the following
list of instructions.  Some commands require the creation of unique temporary
variables, such as @samp{list-211} in the below output.

@lisp
((loopy--iteration-vars (list-211 '(1 2 3)))
 (loopy--iteration-vars (i nil))
 (loopy--pre-conditions (consp list-211))
 (loopy--main-body      (setq i (car list-211)))
 (loopy--latter-body    (setq list-211 (cdr list-211))))
@end lisp

The first element of an instruction describes where to insert code into the
template.  The second element of an instruction is said code to insert.  You
can see that not all of the code to be inserted is a valid Lisp form.  For
example, the above instruction referencing @code{loopy--iteration-vars} inserts
a binding for the variable @samp{list-211} into a @code{let}-like form.

@multitable {aaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Place
@tab Code
@item @samp{loopy--iteration-vars}
@tab @samp{(list-211 '(1 2 3))}
@item @samp{loopy--latter-body}
@tab @samp{(setq list-211 (cdr list-211))}
@item @samp{loopy--pre-conditions}
@tab @samp{(consp list-211)}
@item @samp{loopy--iteration-vars}
@tab @samp{(i nil)}
@item @samp{loopy--main-body}
@tab @samp{(setq i (car list-211)))}
@end multitable

Commands are parsed by @code{loopy--parse-loop-command}, which receives a command
call, such as @samp{(list i '(1 2 3))}, and returns a list of instructions.  It
does this by searching for an appropriate command-specific parsing function
in @code{loopy-command-aliases} and ultimately in @code{loopy-command-parsers}.  For
parsing multiple commands in order, there is @code{loopy--parse-loop-commands},
which wraps the single-command version.

For example, consider the function @code{loopy--parse-if-command}, which parses
the @samp{if} loop command.  It needs to check the instructions of the
sub-commands passed to @samp{if}, looking for code that would be inserted into the
main loop body (as determined by the first element of the instruction).  Once
found, it wraps that code with an @code{if}-form.

@lisp
;; => ((loopy--iteration-vars (i nil))
;;     (loopy--main-body (setq i 1)))
(loopy--parse-loop-command '(expr i 1))

;; => ((loopy--iteration-vars (i nil))
;;     (loopy--main-body (if (my-condition)
;;                           (setq i 1)
;;                         (setq i 2))))
(loopy--parse-if-command '(if (my-condition)
                              (expr i 1)
                            (expr i 2)))
@end lisp

For the purpose of this example, below is a version of the parsing function
made of the basic Lisp features with which you are familiar.  The actual
definition makes use of more convenient Emacs Lisp libraries and can be seen
in the library @file{loopy-commands.el}.

@lisp
(require 'loopy-commands)
(defun loopy--parse-if-command (arg)
  "Parse the `if' loop command usage ARG.
ARG is of the form (if CONDITION IF-TRUE &rest IF-FALSE)."

  (let ((condition (cadr arg))   ; Second element of `arg'.
        (if-true   (caddr arg))  ; Third element of `arg'.
        (if-false  (cdddr arg))) ; Remaining elements of `arg'.

    ;; The main processing of this function is to separate instructions
    ;; for the loop's main body from other instructions,
    ;; and to then wrap those main-body instructions with an
    ;; `if' special form.
    (let ((full-instructions)
          (if-true-main-body)
          (if-false-main-body)
          ;; This variable is just so that iteration commands know when
          ;; they are being used away from the top level of the loop's
          ;; structure (which is an error).
          (loopy--in-sub-level t))

      ;; Process the instructions for the command that should run if the
      ;; condition is true.
      (dolist (instruction (loopy--parse-loop-command if-true))
        (if (eq 'loopy--main-body (car instruction))
            (push (cadr instruction) if-true-main-body)
          (push instruction full-instructions)))

      ;; Process the instructions for the commands that should run
      ;; if the condition is false.
      (dolist (instruction (loopy--parse-loop-commands if-false))
        (if (eq 'loopy--main-body (car instruction))
            (push (cadr instruction) if-false-main-body)
          (push instruction full-instructions)))

      ;; Note: `push' adds elements to the front of a list,
      ;;       so we need to reverse these lists before returning
      ;;       the new list of instructions.

      ;; `loopy--parse-loop-command' always returns a list of instructions.
      ;; For some commands, that means wrapping multiple instructions in
      ;; a `progn' form.  For others, we need to extract the only element.
      (setq if-true-main-body
            (if (= 1 (length if-true-main-body))
                (car if-true-main-body)
              (cons 'progn (nreverse if-true-main-body))))

      ;; Return the new, full list of instructions.
      (cons `(loopy--main-body
              . (if ,condition
                    ,if-true-main-body
                  ,@@(nreverse if-false-main-body)))
            (nreverse full-instructions)))))
@end lisp

The hardest part of this exchange is making sure that the inserted code ends
up in the correct order.

A loop body command has 7 main places to put code:

@vindex loopy--generalized-vars
@table @asis
@item @samp{loopy--generalized-vars}
Lists of a symbol and a macro
expansion that will be given to @samp{cl-symbol-macrolet}.  This is used to
create named @code{setf}-able places.  The expansion you use depends on the kind
of sequence and how the it is updated.

For example, @samp{(list-ref i my-list)} declares @samp{i} to be a symbol which
expands to @samp{(car TEMP-VAR)}, in which @samp{TEMP-VAR} holds the value of
@samp{my-list}.  At the end of the loop body, @samp{TEMP-VAR} is set to its @samp{cdr},
ensuring that the next call to @samp{car} returns the correct value.
@end table

@vindex loopy--iteration-vars
@table @asis
@item @samp{loopy--iteration-vars}
Lists of a symbol and an expression that will be
given to @code{let*}.  This is used for initializing variables needed for
iteration commands, such as the @samp{i} in @samp{(list i '(1 2 3))} or to store the
list @samp{'(1 2 3)} in @samp{(list i '(1 2 3))}.  This also includes variables
needed for destructuring.
@end table

@vindex loopy--accumulation-vars
@table @asis
@item @samp{loopy--accumulation-vars}
Lists of a symbol and an expression that will
be given to @code{let*}.  This is used for initializing variables needed for
accumulation commands, such as the @samp{coll} in @samp{(collect coll my-val)} or any
variables needed for destructuring.
@end table

@vindex loopy--pre-conditions
@table @asis
@item @samp{loopy--pre-conditions}
Expressions that determine if the @samp{while}
loop runs/continues, such as whether a list still has elements in it.
If there is more than one expression, than all expressions are used in
an @samp{and} special form.
@end table

@vindex loopy--main-body
@table @asis
@item @samp{loopy--main-body}
Expressions that make up the main body of the
loop.
@end table

@vindex loopy--latter-body
@table @asis
@item @samp{loopy--latter-body}
Expressions that need to be run after the main
body, such as updating some of variables that determine when a loop ends.
@end table

@vindex loopy--post-conditions
@table @asis
@item @samp{loopy--post-conditions}
Expressions that determine whether the
@samp{while} loop continues, but checked after the loop body has run.  The
code from this is ultimately appended to the latter body before being
substituted in.
@end table

For accumulation commands, you might also wish to place values in the
following:

@vindex loopy--implicit-return
@table @asis
@item @samp{loopy--implicit-return}
A list of values to be returned by the loop if
no other return value is specified/reached. A value is added to this list
when an accumulation command does not specify an accumulation variable, and
in some special other cases.

By default, the implicit return value is @code{loopy-result}, and so this
variable is usually just a list of the symbol @samp{loopy-result}.  When the
@samp{split} flag is enabled, this is a list of values to which @code{loopy-result}
is bound.
@end table

@vindex loopy--accumulation-final-updates
@table @asis
@item @samp{loopy--accumulation-final-updates}
Actions to perform on the
accumulation variable after the loop ends.  Some implied accumulation
commands need to update the variable one final time after ending the loop.
Some examples are:
@enumerate
@item
Correcting the order of elements in a list that was constructed in
reverse.
@item
Coercing the variable into a new sequence type, for commands with the
@code{:result-type} argument.
@end enumerate

Each accumulation variable can only be updated once, in a single way.  For
example, a variable cannot be reversed according to the needs of one
command and then coerced into a new type according to the needs of another.
Commands acting on the same accumulation variable must require the same
final update, if they require any final update.
@end table

There are 4 more variables a loop command can push to, but they are derived
from the macro's arguments.  Adding to them after using a macro argument
might lead to unintended behavior.  You might wish to use them if, for
example, you are concerned with what happens after the loop exits/completes.

@vindex loopy--before-do
@table @asis
@item @samp{loopy--before-do}
Expressions to evaluate before the loop.  These are
derived from the @samp{before-do} macro argument.
@end table

@vindex loopy--after-do
@table @asis
@item @samp{loopy--after-do}
Expressions to evaluate after the loop completes
successfully.  These are derived from the @samp{after-do} macro argument.
@end table

@vindex loopy--final-do
@table @asis
@item @samp{loopy--final-do}
Expressions to evaluate after the loop completes,
regardless of success.  These are derived from the @samp{finally-do} macro
argument.
@end table

@vindex loopy--final-return
@table @asis
@item @samp{loopy--final-return}
An expression that is always returned by the
macro, regardless of any early returns in the loop body.  This is
derived from the @samp{finally-return} macro argument.
@end table


@vindex loopy--loop-name
Some commands might depend on the name of the loop.  The symbol which names
the loop is stored in the variable @code{loopy--loop-name}.  The default value is
@code{nil} for normal loop and uniquely generated for sub-loops created with the
@samp{sub-loop} command.

The structure of the macro’s expanded code depends on the features used
(e.g., @code{loopy} won’t try to declare variables if none exist), but the result
will work similar to the below example.

@lisp
`(cl-symbol-macrolet ,loopy--generalized-vars
   (let* ,loopy--with-vars
     (let ,loopy--accumulation-vars
       (let* ,loopy--iteration-vars
         (let ((loopy--early-return-capture
                (cl-block ,loopy--loop-name
                  (cl-tagbody
                   ,@@loopy--before-do
                   (while ,(cl-case (length loopy--pre-conditions)
                             (0 t)
                             (1 (car loopy--pre-conditions))
                             (t (cons 'and loopy--pre-conditions)))
                     (cl-tagbody
                      ,@@loopy--main-body
                      loopy--continue-tag
                      ,@@loopy--latter-body
                      (unless ,loopy--post-conditions
                        (cl-return-from ,loopy--loop-name
                          ,loopy--implicit-return))))
                   ,@@loopy--after-do
                   loopy--non-returning-exit-tag
                   ,loopy--accumulation-final-updates))
                ,loopy--implicit-return))
           ,@@loopy--final-do
           ,(if loopy--final-return
                loopy--final-return
              'loopy--early-return-capture))))))
@end lisp

@node Hello World
@section Hello World

To implement a custom loop body command, @samp{loopy} needs two pieces of
information:
@enumerate
@item
The keyword that names your command
@item
The parsing function that can turn uses of your command into instructions.
@end enumerate

Importantly, your custom commands cannot share a name.

For example, say that you're tired of typing out
@samp{(do (message "Hello, %s %s" PERSONAL-NAME FAMILY-NAME))} and would prefer
to instead use @samp{(greet PERSONAL-NAME [FAMILY-NAME])}.  This only requires
adding code to the loop's main body, so the definition of the parsing
function is quite simple.

@lisp
(require 'cl-lib)
(cl-defun my-loopy-greet-command-parser
    ((_ personal-name &optional family-name))
  "Greet one with PERSONAL-NAME and optional FAMILY-NAME."
  `((loopy--main-body (if ,family-name
                          (message "Hello, %s %s"
                                   ,personal-name ,family-name)
                        (message "Hello, %s" ,personal-name)))))
@end lisp

@samp{loopy} will pass the entire command expression to the parsing function, and
expects back a list of instructions.

@vindex loopy-command-parsers
To tell @samp{loopy} about this function, add it and the command name @samp{greet} to
the variable @samp{loopy-command-parsers}, which associates commands with parsing
functions.  The function that is paired with the symbol receives the entire
command expression, and should produce a list of valid instructions.

@lisp
;; Using the Map library, for convenience.
(require 'map)
(setf (map-elt loopy-command-parsers 'greet)
      #'my-loopy-greet-command-parser)
@end lisp

After that, you can use your custom command in the loop body.

@lisp
(loopy (list name '(("John" "Deer") ("Jane" "Doe") ("Jimmy")))
       (greet (car name) (cadr name)))
@end lisp

By running @kbd{M-x pp-macroexpand-last-sexp RET} on the above
expression, you can see that it expands to do what we want, as expected.  You
might notice that one shortcoming of the current definition is that if a
function is used to produce the second argument, as in @code{(greet
   (personal-name) (family-name))}, then that function is called twice.  This
occurs with @code{(cadr name)} in the below output, and can cause problems when
using stateful functions.  This particular case can be resolved by using
@code{if-let} to first store the result of @code{(cadr name)}, and is something to keep
in mind when defining Lisp macro expansions in general.

@lisp
;; An example expansion.
(let* ((list-166 '(("John" "Deer") ("Jane" "Doe") ("Jimmy")))
       (name nil))
  (let ((loopy-first-iteration t))
    (cl-block nil
      (while (consp list-166)
        (setq name (car list-166))
        (if (cadr name)
            (message "Hello, %s %s"
                     (car name)
                     (cadr name))
          (message "Hello, %s"
                   (car name)))
        (setq list-166 (cdr list-166))
        (setq loopy-first-iteration nil))
      nil)))
@end lisp

@node An @code{always} Command
@section An @code{always} Command

Lets say we want to emulate @code{cl-loop}'s @samp{always} clause, which causes the
loop to return @code{nil} if an expression evaluates to @code{nil} and @code{t} otherwise.
This is similar to the functions @code{cl-every} and @code{seq-every-p}.

Here is an example:

@lisp
;; => t
(cl-loop for i from 1 to 9 always (< i 10))
@end lisp

While @code{loopy} already has an @samp{always} command, we'll ignore it for the sake
of this example.  Without a custom command, you could translate this using
the following code:

@lisp
;; => t
(loopy (nums i 1 9)
       (unless (< i 10) (return nil))
       (else-do (cl-return t)))
@end lisp

This is similar to what you might write in other languages, such as Python.

@example
# In some testing Python function:
for i in range(1, 10):
    if not (i < 10):
        return False
else:
    return True
@end example

While the meaning of the code is clear, this approach is certainly wordier.

Here's how one could do this using a custom command.  Again, @samp{loopy} already
comes with a built-in @samp{always} command.  This example is taken directly from
the file @file{loopy-commands.el}, which contains the code of all of
@code{loopy}'s built-in parsers.

We can describe the command's desired behavior in two sentences:
@enumerate
@item
The loop should immediately return @code{nil} if the expression ever evaluates
to @code{nil}.
@item
The loop should return @code{t} if the loop is able to complete successfully.
@end enumerate

This simplest way to satisfy the first requirement is to conditionally use
@code{cl-return} if the expressions ever evaluates to @code{nil}.  We want to do this
while the loop is running, so we should use an instruction for
@code{loopy--main-body}.

@lisp
;; We want to insert the below code into the loop
(unless CONDITION
  (cl-return nil))

;; so we use the instruction
`(loopy--main-body (unless ,CONDITION (cl-return nil)))

;; where CONDITION is supplied by the parsing function.
@end lisp

For a simple loop, this works well enough.  However, the function @code{cl-return}
only works with blocks that are named @code{nil}.  If we have named the loop, then
@code{cl-return} won't work, and might instead cause unexpected errors.
Therefore, it is better to use @code{cl-return-from} with the variable
@code{loopy--loop-name}.  As noted in the previous section, @code{loopy--loop-name}
stores the symbol which names the loop.

@lisp
`(loopy--main-body (unless ,CONDITION
                     (cl-return-from ,loopy--loop-name nil)))
@end lisp

The best way to satisfy the second requirement is to use an instruction for
@code{loopy--implicit-return}.  One @emph{could} try to insert code using
@code{cl-return-from} into @code{loopy--after-do}, and this @emph{would} cause a value to be
returned after the loop had successfully completed, but doing it that way
could unexpectedly prevent other code in @samp{after-do} from running.  Using an
implicit return value does not have that problem.

This gives us the following instruction, which will add @code{t} to the list of
values the macro returns if nothing else would be returned.  If that list is
just @code{'(t)}, then the macro knows to just return @code{t}.

@lisp
'(loopy--implicit-return t)
@end lisp

Once we've chosen our instructions, we need to tell @samp{loopy} what function to
use to produce these instructions.  Like in the previous example, we define
the parsing function and add it to @code{loopy-command-parsers}.

@lisp
;; As noted in the previous section, the parsing function is always
;; passed the entire command as `(always CONDTION)', not just the
;; command arguments as `CONDITION'.

(cl-defun my--loopy-always-command-parser ((_ condition))
  "Parse a command of the form `(always CONDITION)'.

If any condition is nil, `loopy' should immediately return nil.
Otherwise, `loopy' should return t."
  `((loopy--implicit-return t)
    (loopy--main-body (unless ,condition
                        (cl-return-from ,loopy--loop-name nil)))))

(setf (map-elt loopy-command-parsers 'always)
      #'my--loopy-always-command-parser)
@end lisp

Once we've added our parsing function to @code{loopy-command-parsers},
@samp{loopy} will use that function whenever it tries to understand the @samp{always}
command.  In this case, this custom parser would supercede the built-in
parser.

With that done, our custom @samp{always} command is as useful as the corresponding
@code{cl-loop} clause.  However, because @code{loopy} uses expressions instead of
keyword clauses like @code{cl-loop}, we can do slightly better.  For convenience,
we can easily allow passing multiple conditions to the command instead of
just one.  In such cases, the conditions should be wrapped in an @code{and} form,
and that is indeed what the built-in parser does.

@lisp
;; The built-in parser, taken from `loopy-commands.el':
(cl-defun loopy--parse-always-command ((_ &rest conditions))
  "Parse a command of the form `(always [CONDITIONS])'.

If any condition is nil, `loopy' should immediately return nil.
Otherwise, `loopy' should return t."
  `((loopy--implicit-return t)
    ;; If there are multiple conditions, wrap these conditions in `and'.
    (loopy--main-body (unless ,(if (= 1 (length conditions))
                                   (cl-first conditions)
                                 `(and ,@@conditions))
                        (cl-return-from ,loopy--loop-name nil)))))
@end lisp

Here are some examples of the command in action:

@lisp
;; One condition: => t
(loopy (list i (number-sequence 1 9)) (always (< i 10)))

;; Two conditions: => nil
(loopy (list i (number-sequence 1 9))
       (list j '(2 4 6 8 9))
       (always (< i 10) (cl-evenp j)))

;; The previous example is equivalent to this.
(loopy (list i (number-sequence 1 9))
       (list j '(2 4 6 8 9))
       (always (and (< i 10) (cl-evenp j))))
@end lisp

@node Finding More Examples
@section Finding More Examples

If you would like to see more examples, consider reading through the source
code of @file{loopy-commands.el}, which contains the code of all of the
built-in loop commands.  You can easily find this file using
@kbd{M-x find-library loopy-commands RET}.

@node Comparing to @code{cl-loop}
@chapter Comparing to @code{cl-loop}

@code{loopy} should be comparable with @code{cl-loop} for most things, keeping in
mind the following:
@itemize
@item
It is more flexible than @code{cl-loop}, at the cost of being slightly slower
depending on the features used.
@item
It has more flexible control-flow commands, under which you can easily group
sub-commands, including assignments.
@item
It has more flexible accumulation commands.
@item
It has more flexible iteration commands.
@item
It has a @samp{skip} command to skip the rest of the loop body and immediately
start the next iteration.  Of course, a similar effect could be achieved
using the @samp{when} or @samp{unless} commands.
@end itemize

@code{loopy} is not always one-to-one replacement for @code{cl-loop}, but it is easy to
use and extend, and performs well in the cases that it already handles.

Below is a simple example of @code{loopy} vs @code{cl-loop}.

@lisp
(require 'cl-lib)
(cl-loop with some-thing = 5
         for i from 1 to 100
         do (message "I is %s" i)
         when (> (+ i 5) 20)
         return (format "Done: %d" i))

(require 'loopy)
(loopy (with (some-thing 5))
       (nums i 1 100)
       (do (message "I is %s" i))
       (when (> (+ i 5) 20)
         (return (format "Done: %d" i))))
@end lisp

The main benefit (I believe) of Loopy is clearer grouping of commands under
conditionals while still using a clean syntax, such as in the below example.

@lisp
;; => '((2 4) (4 8) (6 12) (8 16) (10 20))
(loopy (nums i 1 10)
       (when (cl-evenp i)
         (expr once i)
         (expr twice (* 2 i))
         (collect doubles (list once twice)))
       (finally-return doubles))
@end lisp

In my experience, @code{cl-loop} does not allow the easy grouping of assignment
statements under a @samp{when} condition.  For example, below is something I would
like to try to do with @code{cl-loop}.

I am aware that in this example the @samp{for} statements aren't necessary and that
the @samp{collect} statements would be sufficient, but (when I come across things
like this in my work) I would like to use them to declare variables for
readability purposes.

@lisp
(require 'cl-lib)
(save-match-data
  (cl-loop with pattern = "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"
           for line in (split-string "Line1-Data1\nBad\nLine2-Data2")
           when (string-match pattern line)
           for line-num = (concat "L" (match-string 1 line))
           and for data-num = (concat "D" (match-string 2 line))

           ;; … Further processing now that data is named …

           and collect line-num into line-nums
           and collect data-num into data-nums
           finally return (list line-nums data-nums)))

;; Normal Elisp:
(save-match-data
  (let ((pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)")
        (line-nums)
        (data-nums))
    (dolist (line (split-string "Line1-Data1\nBad\nLine2-Data2"))
      (when (string-match pattern line)
        (let ((line-num (concat "L" (match-string 1 line)))
              (datum-num (concat "D" (match-string 2 line))))

          ;; … Further processing now that data is named …

          (push line-num line-nums)
          (push datum-num data-nums))))
    (list (nreverse line-nums) (nreverse data-nums))))
@end lisp

Here is how one could currently do it with @code{loopy}:

@lisp
(require 'loopy)
(save-match-data
  (loopy (with (pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"))
         (list line (split-string "Line1-Data1\nBad\nLine2-Data2"))
         (when (string-match pattern line)
           (expr line-num (concat "L" (match-string 1 line)))
           (expr datum-num (concat "D" (match-string 2 line)))

           ;; … Further processing now that data is named …

           (collect line-nums line-num)
           (collect data-nums datum-num))
         (finally-return line-nums data-nums)))
@end lisp

I believe that the value of the macro increases for longer loop bodies with
several conditional commands.

Another nice ability, one that I'm not sure @code{cl-loop} has, is a specific
command for skipping/continuing a loop iteration.  Of course, one could also
re-organize code under a conditional command like @samp{when} to achieve the same
effect.

@lisp
;; Returns even numbers that aren't multiples of 10.
;;
;; => (2 4 6 8 12 14 16 18)
(loopy (nums i 1 20)
       (when (zerop (mod i 10))
         (skip))
       (when (cl-evenp i)
         (collect i)))
@end lisp

@node Translating to and from @samp{cl-loop}
@chapter Translating to and from @samp{cl-loop}

@code{loopy} and @code{cl-loop} use slightly different terminology.  The equivalent of
``for clauses'' are referred to as ``iteration commands'' in @code{loopy}, as they
generally are used for iterating through sequences.  Meanwhile, ``iteration
clauses'' can be separated into ``iteration commands'' (@samp{repeat} and @samp{iter-by}
(not yet implemented)) and ``early-exit commands'' (@samp{while} and @samp{until}).

``Accumulation clauses'' work the same as ``accumulation commands''.

@menu
* For Clauses::
* Iteration Clauses::
* Accumulation Clauses::
* Other Clauses::
@end menu

@node For Clauses
@section For Clauses

As Emacs has many functions that return lists, there is no need to implement
an exact equivalent for every @samp{for}-clause that @code{cl-loop} has.  Instead, one
can just iterate through the return value of the appropriate function using
the @samp{list} command.

For the commands operating on hash tables, see also the generic iteration
command @samp{map-pairs}, which works generically on hash tables, association
lists (``alists''), property lists (``plists''), and vectors.

@multitable {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem @code{cl-loop}
@tab @code{loopy}
@item @samp{for VAR from EXPR1 to EXPR2 by EXPR3}
@tab @samp{(numbers VAR EXPR1 EXPR2 :by EXPR3)}
@item @samp{for VAR in LIST [by FUNCTION]}
@tab @samp{(list VAR LIST :by FUNC)}
@item @samp{for VAR on LIST [by FUNCTION]}
@tab @samp{(cons VAR VAL :by FUNC)}
@item @samp{for VAR in-ref LIST by FUNCTION}
@tab @samp{(list-ref VAR LIST :by FUNC)}
@item @samp{for VAR across ARRAY}
@tab @samp{(array VAR ARRAY)}
@item @samp{for VAR across-ref ARRAY}
@tab @samp{(array-ref VAR ARRAY)}
@item @samp{for VAR being the elements of SEQUENCE}
@tab @samp{(seq VAR SEQUENCE)}
@item @samp{for VAR being the elements of-ref SEQUENCE}
@tab @samp{(seq-ref VAR SEQUENCE)}
@item @samp{for VAR being the symbols [of OBARRAY]}
@tab None so far.  Use @code{mapatoms}.
@item @samp{for VAR being the hash-keys of HASH-TABLE}
@tab @samp{(list VAR (hash-table-keys HASH-TABLE))}
@item @samp{for VAR being the hash-values of HASH-TABLE}
@tab @samp{(list VAR (hash-table-values HASH-TABLE))}
@item @samp{for VAR being the key-codes of KEYMAP}
@tab None so far.  Use @code{map-keymap}.
@item @samp{for VAR being the key-bindings of KEYMAP}
@tab None so far.  Use @code{map-keymap}.
@item @samp{for VAR being the key-seqs of KEYMAP}
@tab None so far.
@item @samp{for VAR being the overlays [of BUFFER]}
@tab None so far.  Use @code{overlay-lists}.
@item @samp{for VAR being the intervals [of BUFFER]}
@tab None so far.
@item @samp{for VAR being the frames}
@tab @samp{(list VAR (frame-list))}
@item @samp{for VAR being the windows [of FRAME]}
@tab @samp{(list VAR (window-list FRAME))}
@item @samp{for VAR being the buffers}
@tab @samp{(list VAR (buffer-list))}
@item @samp{for VAR = EXPR1 then EXPR2}
@tab @samp{(expr VAR EXPR1 EXPR2)}
@end multitable

@node Iteration Clauses
@section Iteration Clauses

@multitable {aaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaa}
@headitem @code{cl-loop}
@tab @code{loopy}
@item @samp{repeat INT}
@tab @samp{(repeat INT)}
@item @samp{while COND}
@tab @samp{(while COND)}
@item @samp{until COND}
@tab @samp{(until COND)}
@item @samp{iter-by iterator}
@tab None so far.
@item @samp{never}
@tab @samp{(never COND)}
@item @samp{always}
@tab @samp{(always COND)}
@item @samp{thereis}
@tab @samp{(thereis COND)}
@end multitable

@node Accumulation Clauses
@section Accumulation Clauses

Like with @code{cl-loop}, in @code{loopy}, accumulation commands accumulate into the
same variable when no @samp{VAR} is given (by default, @code{loopy-result}).  If you
would like accumulation commands to accumulate into separate variables,
simple provide @samp{VAR} to the command or use the @samp{split} flag (@ref{Using Flags}).

@multitable {aaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaa}
@headitem @code{cl-loop}
@tab @code{loopy}
@item @samp{append EXPR into VAR}
@tab @samp{(append VAR EXPR)}
@item @samp{collect EXPR into VAR}
@tab @samp{(collect VAR EXPR)}
@item @samp{concat EXPR into VAR}
@tab @samp{(concat VAR EXPR)}
@item @samp{count EXPR into VAR}
@tab @samp{(count VAR EXPR)}
@item @samp{maximize EXPR into VAR}
@tab @samp{(max VAR EXPR)}
@item @samp{minimize EXPR into VAR}
@tab @samp{(min VAR EXPR)}
@item @samp{nconc EXPR into VAR}
@tab @samp{(nconc VAR EXPR)}
@item @samp{sum EXPR into VAR}
@tab @samp{(sum VAR EXPR)}
@item @samp{vconcat EXPR into VAR}
@tab @samp{(vconcat VAR EXPR)}
@end multitable

@node Other Clauses
@section Other Clauses

In @code{loopy}, @samp{if}, @samp{when}, and @samp{unless} can take multiple loop commands as
arguments, and operate more like their Lisp counterparts.

This means that @samp{if} is not a synonym for @samp{when}.  Just like the normal Lisp
special form @code{if}, @samp{(if COND cmd1 cmd2 cmd3)} only runs @samp{cmd1} if @samp{COND}
evaluates to non-nil, and only runs commands @samp{cmd2} and @samp{cmd3} if @samp{COND}
evaluates to @code{nil}.

@code{loopy} also provides the command @samp{cond}, which works like the normal Lisp
special form @code{cond}.

@multitable {aaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem @code{cl-loop}
@tab @code{loopy}
@item @samp{with var = value}
@tab @samp{(with (VAR VALUE))} as a macro argument
@item @samp{if COND clause}
@tab @samp{(if COND CMDS)} as a loop command
@item @samp{when COND clause}
@tab @samp{(when COND CMDS)} as a loop command
@item @samp{unless COND clause}
@tab @samp{(unless COND CMDS)} as a loop command
@item @samp{named NAME}
@tab @samp{NAME} as a macro argument
@item @samp{initially [do] EXPRS}
@tab @samp{(before-do EXPRS)} as a macro argument
@item @samp{finally [do] EXPRS}
@tab @samp{(finally-do EXPRS)} as a macro argument
@item @samp{finally return EXPR}
@tab @samp{(finally-return EXPR)} as a macro argument
@item @samp{do EXPRS}
@tab @samp{(do EXPRS)} as a loop command
@item @samp{return EXPR}
@tab @samp{(return EXPR)} as a loop command
@end multitable

@node Real-World Examples
@chapter Real-World Examples

This section contains examples of loops that exist in real-world commands.  To
see these loops in context, full examples of those commands can be found
online in the file @file{examples/loopy-examples.el} in this package's
repository @footnote{@uref{https://github.com/okamsn/loopy}}.

One command that could see a benefit from using @samp{loopy} is @samp{selectrum-swiper}
from the Selectrum wiki @footnote{@uref{https://github.com/raxod502/selectrum/wiki/Useful-Commands#swiper-like-jumping-to-matching-lines}}.  This command allows a user to jump to
a matched line in the buffer.  Candidates are created by looping through text
lines, formatting non-empty lines and collecting the formatted lines into a
list of candidates.  At the same time, it selects a default candidate by
finding the non-empty line closest to the current line.

Here is the main portion of the command, which uses @code{cl-loop}.

@lisp
;; ...
(cl-loop
 with buffer-lines = (split-string (buffer-string) "\n")
 with number-format = (concat "L%0"
                              (number-to-string
                               (length (number-to-string
                                        (length buffer-lines))))
                              "d: ")

 with formatted-candidates = nil
 for line-text in buffer-lines
 for line-num = (line-number-at-pos (point-min) t) then (1+ line-num)

 with default-candidate = nil
 with prev-distance-to-default-cand = 1.0e+INF ; This updated later.
 for distance-to-default-cand = (abs (- current-line-number line-num))

 unless (string-empty-p line-text)      ; Just skip empty lines.
 do
 ;; Find if we’ve started to move away from the current line.
 (when (null default-candidate)
   (when (> distance-to-default-cand
            prev-distance-to-default-cand)
     (setq default-candidate (cl-first formatted-candidates)))
   (setq prev-distance-to-default-cand distance-to-default-cand))

 ;; Format current line and collect candidate.
 (push (propertize line-text
                   'selectrum-candidate-display-prefix
                   (propertize (format number-format line-num)
                               'face 'completions-annotations)
                   'line-num line-num)
       formatted-candidates)

 finally return (list default-candidate
                      (nreverse formatted-candidates)))
;; ...
@end lisp

The limitations of @code{cl-loop}'s @samp{when} clause encourages relying on Lisp
expressions rather than clauses for processing.  To use those Lisp
expressions, one must declare more variables with the @samp{with} clause to ensure
that those variables are locally scoped.

Here is how it could be done with @samp{loopy}:

@lisp
;; ...
(loopy
 (with (buffer-text-lines (split-string (buffer-string) "\n"))
       (number-format (concat "L%0"
                              (number-to-string
                               (length (number-to-string
                                        (length buffer-text-lines))))
                              "d: ")))
 (list line-text buffer-text-lines)
 (expr line-num (line-number-at-pos (point-min) t)
       (1+ line-num))
 (unless (string-empty-p line-text)
   (push-into formatted-candidates
              (propertize line-text
                          'selectrum-candidate-display-prefix
                          (propertize (format number-format line-num)
                                      'face 'completions-annotations)
                          'line-num line-num))
   ;; There are a few different ways that you could express
   ;; this.
   (when (null default-candidate)
     (expr prev-dist +1.0e+INF dist-to-default-cand)
     (expr dist-to-default-cand (abs (- current-line-number
                                        line-num)))
     (when (> dist-to-default-cand prev-dist)
       (expr default-candidate (cl-second formatted-candidates)))))
 (finally-return default-candidate (nreverse formatted-candidates)))
;; ...
@end lisp

We can see that most of the loop commands are easily grouped under the
@samp{unless} command.  This allows for less noise, as we do not need to declare
variables or fall back to using more Lisp expressions.

Another good example is the command @samp{selectrum-outline} from the same page.
This command is similar to @samp{selectrum-swiper}, but has a slightly more
complicated processing portion.

The code loops through each line in the buffer, searching for lines that match
a pre-determined regular expression.  The match data is used to determine the
heading level (top level, second level, etc.) and the actual heading text.
The loop produces formatted candidates by prepending this heading text with
the text of parent headings, as determined by the heading level.  At the same
time, the loop selects the current heading as the default candidate.

Instead of using @code{cl-loop}, this command is written in conventional Emacs
Lisp.

@lisp
;; ...
(let (;; Get the basic information of each heading in the accessible
      ;; portion of the buffer.
      (buffer-lines (split-string (buffer-string) "\n"))
      (line-number 0)
      (line-number-format)

      ;; Finding the default heading
      (default-heading)
      (current-line-number (line-number-at-pos (point)))

      ;; Keeping track of the tree.
      (backwards-prefix-list)
      (prev-heading-text)
      (prev-heading-level)

      ;; Backwards result of the ‘dolist'. Will ‘nreverse’.
      (formatted-headings))

  (setq line-number-format
        (concat "L%0"
                (number-to-string
                 (length (number-to-string (length buffer-lines))))
                "d: "))

  (save-match-data
    (dolist (text-line buffer-lines)
      ;; Increment line number when moving to next.
      (cl-incf line-number)
      (when (string-match heading-regexp text-line)
        (let ((heading-text (match-string-no-properties 2 text-line))
              (heading-level
               (length (match-string-no-properties 1 text-line))))

          ;; Make sure this has a valid value when we first compare.  The
          ;; first comparison should be equal, so that nothing is
          ;; needlessly added to the prefix list, which causes bad
          ;; formatting.
          (unless prev-heading-level
            (setq prev-heading-level heading-level))

          ;; Decide whether to update the prefix list and the previous
          ;; heading level.
          (cond
           ;; If we've moved to a greater level (further down the tree),
           ;; add the previous heading to the heading prefix list so
           ;; that we can prepend it to the current heading when
           ;; formatting.
           ((> heading-level prev-heading-level)
            (setq backwards-prefix-list (cons prev-heading-text
                                              backwards-prefix-list)
                  prev-heading-level heading-level))
           ;; Otherwise, if we've moved to a lower level (higher up the
           ;; tree), and need to remove the most recently added prefix
           ;; from the list (i.e., go from '(c b a) back to '(b a)).
           ((< heading-level prev-heading-level)
            (setq backwards-prefix-list (last backwards-prefix-list
                                              heading-level)
                  prev-heading-level heading-level)))

          ;; Regardless of what happens, update the previous heading text.
          (setq prev-heading-text heading-text)

          ;; Decide whether the previous formatted heading was the
          ;; default.
          (when (and (null default-heading)
                     (> line-number current-line-number))
            (setq default-heading (cl-first formatted-headings)))

          ;; Finally, add to list of formatted headings.
          ;; Create heading of form "L#: a/b/c" as:
          ;; - having a text property holding the line number
          ;; - prepended with a formatted line number,
          ;;   with the face ‘completions-annotations’.
          (push (propertize
                 (concat (string-join (reverse backwards-prefix-list) "/")
                         (and backwards-prefix-list "/")
                         heading-text)
                 'line-number line-number
                 'selectrum-candidate-display-prefix
                 (propertize
                  (format line-number-format line-number)
                  'face 'completions-annotations))
                formatted-headings)))))
  ;; ...
  )
@end lisp

Here is a version in @samp{loopy} (which is more of a straight translation than a
re-working):

@lisp
;; ...
(loopy
 (with (buffer-lines (split-string (buffer-string) "\n"))
       (line-number-format
        (concat "L%0"
                (number-to-string
                 (length (number-to-string (length buffer-lines))))
                "d: ")))
 (expr line-number 1 (1+ line-number))
 (list text-line buffer-lines)
 (when (string-match heading-regexp text-line)
   (expr heading-text
         (match-string-no-properties 2 text-line))
   (expr heading-level
         (length (match-string-no-properties 1 text-line)))

   ;; Decide whether to update the prefix list and the previous
   ;; heading level.
   (cond
    ;; If we've moved to a greater level (further down the tree),
    ;; add the previous heading to the heading prefix list so that
    ;; we can prepend it to the current heading when formatting.
    ((> heading-level (or prev-heading-level heading-level))

     (push-into backwards-prefix-list prev-heading-text)
     (expr prev-heading-level heading-level))
    ;; Otherwise, if we've moved to a lower level (higher up the
    ;; tree), and need to remove the most recently added prefix
    ;; from the list (i.e., go from '(c b a) back to '(b a)).
    ((< heading-level (or prev-heading-level heading-level))
     (expr backwards-prefix-list (last backwards-prefix-list
                                       heading-level))
     (expr prev-heading-level heading-level)))

   ;; Regardless of what happens, update the previous heading
   ;; text.
   (expr prev-heading-text heading-text)

   ;; Decide whether the previous formatted heading was the
   ;; default.
   (when (and (null default-heading)
              (> line-number current-line-number))
     (expr default-heading (car formatted-headings)))

   ;; Finally, add to list of formatted headings.
   ;; Create heading of form "L#: a/b/c" as:
   ;; - having a text property holding the line number
   ;; - prepended with a formatted line number,
   ;;   with the face ‘completions-annotations’.
   (push-into
    formatted-headings
    (propertize
     (concat (string-join
              (reverse backwards-prefix-list) "/")
             (and backwards-prefix-list "/")
             heading-text)
     'line-number line-number
     'selectrum-candidate-display-prefix
     (propertize (format line-number-format line-number)
                 'face 'completions-annotations))))
 (finally-return default-heading (nreverse formatted-headings)))
;; ...
@end lisp

In my opinion, the @samp{loopy} version is a bit cleaner.  Even when following the
same flow of logic, you still get the benefit of less typing with no loss in
clarity.

If one were writing code like this often (say, in a library), then the loop
body could be simplified even further with custom commands
(@ref{Custom Commands}).

@node Macro Argument and Loop Command Index
@chapter Macro Argument and Loop Command Index

@printindex fn

@node Variable Index
@chapter Variable Index

@printindex vr

@node Concept Index
@chapter Concept Index

@printindex cp

@bye