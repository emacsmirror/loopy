\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename loopy.info
@settitle Loopy: A Looping and Iteration Macro
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@dircategory Emacs
@direntry
* Loopy: (loopy).       A looping and iteration macro.
@end direntry

@finalout
@titlepage
@title Loopy: A Looping and Iteration Macro
@author Earl Hyatt
@end titlepage

@contents

@ifnottex
@node Top
@top Loopy: A Looping and Iteration Macro

@samp{loopy} is a macro meant for iterating and looping.  It is similar in usage to
@code{cl-loop} (@ref{Loop Facility,,,cl,}) but uses symbolic expressions rather than
keywords.

@samp{loopy} should be complementary to the features provided by the @samp{seq}
(@ref{Sequence Functions,,,elisp,}) and @samp{cl-lib} (@ref{Top,,,cl,}) libraries (including
@samp{cl-loop}) and Emacs's regular looping and mapping features.

@end ifnottex

@menu
* Introduction::                 A short overview.
* Basic Concepts::               Basic information about `loopy' and its loops.
* Special Macro Arguments::      Creating the environment of the loop.
* Loop Commands::                The main features of `loopy'.
* Changing the Macro's Behavior with Flags::
* Adding Custom Commands::
* How does it compare to @samp{cl-loop}?::
* Real-World Examples::
* Keyword and Command Index::
* Variable Index::
* Concept Index::

@detailmenu
--- The Detailed Node Listing ---

Loop Commands

* Commands for Generic Evaluation::
* Iteration and Looping Commands::
* Accumulation Commands::
* Control Flow::
* Sub-loops::

Control Flow

* Conditionals::
* Skipping an Iteration::
* Exiting the Loop Early::

Adding Custom Commands

* Background Information::
* A Small Example::
* A Slightly More Complicated Example::

How does it compare to @samp{cl-loop}?

* Translating from @samp{cl-loop}::

Translating from @samp{cl-loop}

* For Clauses::
* Iteration Clauses::
* Accumulation Clauses::
* Other Clauses::

@end detailmenu
@end menu

@node Introduction
@chapter Introduction

The @code{loopy} macro is used to generate code for a loop, similar to @code{cl-loop}.
Unlike @code{cl-loop}, @code{loopy} uses symbolic expressions instead of ``clauses''.

@lisp
;; A simple usage of `cl-loop':
(cl-loop for i from 1 to 10
         if (cl-evenp i) collect i into evens
         else collect i into odds
         end ; This `end' keyword is optional here.
         finally return (list odds evens))

;; How it could be done using `loopy':
(loopy (list i (number-sequence 1 10))
       (if (cl-evenp i)
           (collect evens i)
         (collect odds i))
       (finally-return odds evens))
@end lisp

@code{loopy} supports destructuring for iteration commands like @samp{list} and
accumulation commands like @code{collect}.

@lisp
;; Summing the nth elements of arrays:
;; => (8 10 12 14 16 18)
(loopy (list (list-elem1 list-elem2)
             '(([1 2 3] [4 5 6])
               ([7 8 9] [10 11 12])))
       (sum [sum1 sum2 sum3] list-elem1)
       (sum [sum4 sum5 sum6] list-elem2))

;; Or, more simply:
;; => (8 10 12 14 16 18)
(loopy (list list-elem '(([1 2 3] [4 5 6])
                         ([7 8 9] [10 11 12])))
       (sum ([sum1 sum2 sum3] [sum4 sum5 sum6])
            list-elem))
@end lisp

The @code{loopy} macro is configurable and extensible.  In addition to writing one's
own ``loop commands'' (such as @samp{list} in the example below), by using ``flags'',
one can choose whether to instead use @code{pcase-let}, @code{seq-let}, or even the Dash
library for destructuring.

@lisp
;; Use Seq.el to destructure an array:
;; => ((1 4) ([2 3] [5 6]))
(loopy (flag seq)
       (list elem '([1 2 3] [4 5 6]))
       (collect [i &rest j] elem))
@end lisp

Variables like @samp{elem}, @samp{i}, and @samp{j} in the example above are automatically
@code{let}-bound so as to not affect code outside of the loop.

@code{loopy} has arguments for binding (or not binding) variables, executing code
before/after the loop, executing code only if the loop completes, and for
setting the macro's return value (default @code{nil}).  This is in addition to the
looping features themselves.

All of this makes @code{loopy} a useful and convenient choice for looping and
iteration.

That being said, Loopy is not yet feature complete.  Please request features
or report problems in this project’s @uref{https://github.com/okamsn/loopy/issues, issues tracker}.  While most cases are
covered, full feature parity with some of the more niche uses of @samp{cl-loop} is
still being worked on.

@node Basic Concepts
@chapter Basic Concepts

Except for an optional loop name, all arguments of the @code{loopy} macro are
symbolic expressions that create a loop, assigns variables in the lexical
environment that surrounds the loop, adds code that runs before/after the
loop, and sets the ultimate return value of the macro.

For convenience and clarity, symbolic expressions that generate code in the
loop body are called ``loop commands'' (@ref{Loop Commands}).  Symbolic
expressions that generate code around the loop are called ``special macro
arguments'' or just ``macro arguments'' as opposed to ``loop commands''
(@ref{Special Macro Arguments}).

``Loop commands'' are the main feature of the @code{loopy} macro, such as the @samp{list}
in @samp{(list i '(1 2 3))}.  A command inserts code into the loop body, but can
also perform additional setup like initializing variables.  Many commands set
a condition for ending the loop.

The loop ends when any condition required by a loop command evaluates to
false.  If no conditions are needed, the loop runs infinitely until a @samp{return}
or @samp{return-from} command is reached (@ref{Exiting the Loop Early}).

Except when using accumulating loop commands (@ref{Accumulation Commands}), return
values must be stated explicitly, either as an early return in the loop body
via the @samp{return} or @samp{return-from} commands, or as part of the @samp{finally-return}
macro argument.  @samp{nil} is returned by default.

@node Special Macro Arguments
@chapter Special Macro Arguments

@cindex special macro argument
There are 7 special macro arguments. One, an unquoted symbol, is taken as the
loop's name. The others, listed below, are symbolic expressions that begin
with a keyword or one of their aliases. You do not need to use all of them.

If a macro argument does not match one of these special 7, @code{loopy} will
attempt to interpret it as a loop command, and throw an error if that fails.

@findex with, let*
@table @asis
@item @samp{with}, @samp{let*}
Declare variables before the loop.

@lisp
(loopy (with (a 1) (b 2)) ...)
(loopy (let* (a 1) (b 2)) ...)
@end lisp
@end table

@findex without, no-init
@table @asis
@item @samp{without}, @samp{no-init}
Variables that @code{loopy} should not try to
initialize.  @code{loopy} tries to initialize all the variables it uses in a
@code{let}-like form, but that isn’t always desired.

@lisp
(let ((a 5))
  ;; Without `without', `loopy' would try to initialize `a' to nil, which would
  ;; overwrite the value of 5 above.
  (loopy (without a)
         (while (not (zerop a)))
         (expr a (1- a)))

  (loopy (no-init a)
         (while (not (zerop a)))
         (expr a (1- a))))
@end lisp
@end table

@findex before-do, before
@table @asis
@item @samp{before-do}, @samp{before}
Run Lisp expressions before the loop starts.

@lisp
(loopy (before-do (message "1: before loop")
                  (message "2: before loop"))
       ...)

(loopy (before (message "1: before loop")
               (message "2: before loop"))
       ...)
@end lisp
@end table

@findex after-do, after, else-do, else
@table @asis
@item @samp{after-do}, @samp{after}, @samp{else-do}, @samp{else}
Run Lisp expressions after the
loop successfully completes.  This is similar to Python’s @code{else} loop
clause.

@lisp
(loopy (list i '(2 4 6 8))
       (when (cl-oddp i)
         (do (message "Odd number found."))
         (leave))
       (after-do (message "No odd number found.")))

(loopy (list i '(2 4 6 8))
       (when (cl-oddp i)
         (do (message "Odd number found."))
         (leave))
       (after (message "No odd number found.")))

(loopy (list i '(2 4 6 8))
       (when (cl-oddp i)
         (do (message "Odd number found."))
         (leave))
       (else-do (message "No odd number found.")))

(loopy (list i '(2 4 6 8))
       (when (cl-oddp i)
         (do (message "Odd number found."))
         (leave))
       (else (message "No odd number found.")))
@end lisp
@end table

@findex finally-do, finally
@table @asis
@item @samp{finally-do}, @samp{finally}
Always run Lisp expressions after the loop
exits.

@lisp
(loopy (list i '(1 2 3))
       (when (cl-oddp i) (break))
       (after-do (message "This not messaged."))
       (finally-do (message "This always messaged.")))

(loopy (list i '(1 2 3))
       (when (cl-oddp i) (break))
       (after-do (message "This not messaged."))
       (finally (message "This always messaged.")))
@end lisp
@end table

@findex finally-return
@table @asis
@item @samp{finally-return}
Return a value, regardless of how the loop
completes.  Accumulation commands have an implicit return value, but this
overrides them.

@lisp
(loopy (list i '(1 2 3))
       (when (cl-oddp i)
         (return "This return value is over-ridden."))
       (finally-return "This string always returned."))
@end lisp
@end table

@findex flag, flags
@table @asis
@item @samp{flag}, @samp{flags}
Options that change the behavior of @code{loopy}.  See the
section [BROKEN LINK: *Destructuring with =dash=] for an example.

@lisp
(loopy (flag dash)
       (list (whole &as a b) '((1 2) (3 4)))
       ...)

(loopy (flags dash)
       (list (whole &as a b) '((1 2) (3 4)))
       ...)
@end lisp
@end table

The loop body and any expressions that are part of the @samp{before-do} and
@samp{after-do} arguments are contained in a single @samp{cl-block}.  Naming the loop
really just names the block, allowing for more specific exiting via
@code{cl-return} and the loop commands that wrap it.

Finally, @samp{(finally-return 1 2 3)} is the same as @samp{(finally-return (list 1 2
  3))}.  This is convenient when using @code{seq-let}, @code{pcase-let},
@code{cl-destructuring-bind}, and the like.

@node Loop Commands
@chapter Loop Commands

@cindex loop command
If a macro argument does not match one of the special 7 arguments described
in @ref{Special Macro Arguments}, @code{loopy} will attempt to treat it as a loop command.
Loop commands are only valid as a top-level argument to the macro, or inside
another loop command.

Therefore, these macro calls are valid:

@lisp
(loopy (list i '(1 2 3))
       (collect coll i)
       ;; Special macro argument:
       (finally-return coll))

;; Implicit accumulation variable and implicit return value:
(loopy (list i '(1 2 3))
       (collect i))
@end lisp

and this is not:

@lisp
(loopy (with (list i '(1 2 3)))
       (finally-return (collect coll i)))
@end lisp

Trying to use loop commands where they don't belong will result in errors
when the code is evaluated.

Underneath, interpreting a command results in ``instructions'' that describe
how to substitute code into the loop body and other locations.  This process
is described in detail in @ref{Background Information}.

Some examples of instructions are:
@itemize
@item
Declaring a given variable in a let form to make sure it's locally
scoped.
@item
Declaring a generated variable in a let form to contain a given value.
@item
Adding a condition for continuing/exiting the loop.
@item
Adding code to be run during the main loop body.
@item
Adding code to be run after the main loop body.
@end itemize

Unless you are writing custom commands, you should not need to know about a
command’s underlying instructions.  However, you should keep in mind that
commands and their resulting instructions are evaluated in order.  This means
that attempting to do something like

@lisp
;; => (nil 1 2)
(loopy (collect coll i)
       (list i '(1 2 3))
       (finally-return coll))
@end lisp

might not do what you expect, as @samp{i} is assigned a value from the list after
collecting @samp{i} into @samp{coll}.

For convenience and understanding, the same command might have multiple names
(such as @samp{expr} having the alias @samp{set}), and some commands can take optional
arguments (such as @samp{list}).

For simplicity, the commands are described using the following notation:

@itemize
@item
If a command has multiple names, the names are separated by a vertical
bar, such as in @samp{expr|set}.
@item
@samp{VAR} is an unquoted symbol that will be used as a variable name, such as
@samp{i} in @samp{(list i my-list)}.
@item
@samp{FUNC} is a Lisp function name, such as @samp{my-func}, @samp{#'my-func} or
@samp{'my-func}.
@item
@samp{NAME} is an unquoted name of a loop (or, more accurately, of a
@samp{cl-block}).
@item
@samp{EXPR} is a single Lisp expression, such as @samp{(+ 1 2)}, @samp{'(1 2 3)},
@samp{my-var}, or @samp{(some-function my-var)}.  @samp{EXPRS} means multiple expressions.
Really, we are concerned with the value of the expression, not the
expression itself.
@item
@samp{CMD} is a loop command, as opposed to a normal Lisp expression.
@samp{(list i '(1 2 3))}, @samp{(repeat 5)}, and @samp{(return-from outer-loop 7)}
are examples of loop commands.  @samp{CMDS} means multiple commands.
@item
Optional arguments are surround by brackets.  @samp{[EXPR]} is an optional
expression, and @samp{[CMD]} is an optional command.  By extension,
@samp{[EXPRS]} is equivalent to @samp{[EXPR [EXPR [...]]]}, and @samp{[CMDS]} to
@samp{[CMD [CMD [...]]]}.
@end itemize

Generally, @samp{VAR} is initialized to @code{nil}, but not always.  This document
tries to note when that is not the case.

@cindex variable destructuring
For convenience, @samp{VAR} can be a sequence, either a list or a vector (as a
stand-in for an array), of symbols instead of a single symbol.  This tells
the command to “de-structure” the value of @samp{EXPR}, similar to the functions
@code{seq-let}, @code{cl-destructuring-bind}, and @code{pcase-let}.  This sequence of
symbols can be shorter than the destructured sequence, @emph{but not longer}.  If
shorter, the unassigned elements of the list are simply ignored.  To assign
the final @code{cdr} of a destructured list, use dotted notation.

@lisp
;; => [(9 10 11 4) (9 10 11 8)]
(loopy (with (my-array [(1 2 3 4) (5 6 7 8)]))
       (array-ref (i j k) my-array)
       ;; NOTE: The remaining elements are ignored.
       (do (setf i 9)
           (setf j 10)
           (setf k 11))
       (finally-return my-array))

;; => ([9 10 11 4] [9 10 11 8])
(loopy (with (my-list '([1 2 3 4 ] [5 6 7 8])))
       (list-ref [i j k] my-list)
       ;; NOTE: The remaining elements are ignored.
       (do (setf i 9)
           (setf j 10)
           (setf k 11))
       (finally-return my-list))

;; => (1 (2 3))
(loopy (list (i . j) '((1 2 3)))
       (finally-return i j))

;; => ((1 22))
(loopy (with (my-list '((1 2 3))))
       (list-ref (_ . j) my-list)
       (do (setf j '(22)))
       (finally-return my-list))

;; => [(1 22)]
(loopy (with (my-array [(1 2 3)]))
       (array-ref (_ . j) my-array)
       (do (setf j '(22)))
       (finally-return my-array))
@end lisp

Most commands that assign variables (even the @samp{-ref} commands, which use
@code{setf}-able places instead of actual variables) can use destructuring, but
not all kinds of destructuring make sense in all situations.

@menu
* Commands for Generic Evaluation::
* Iteration and Looping Commands::
* Accumulation Commands::
* Control Flow::
* Sub-loops::
@end menu

@node Commands for Generic Evaluation
@section Commands for Generic Evaluation

@findex do
@table @asis
@item @samp{(do EXPRS)}
Evaluate multiple Lisp expressions, like a @samp{progn}.

You cannot include arbitrary code in the loop body.  Trying to do so will
result in errors, as the macro will attempt to interpret such code as a
command.

@lisp
(loopy (list i '(1 2 3))
       (do (message "%d" i)))
@end lisp
@end table

@findex expr, exprs, set
@table @asis
@item @samp{(expr|exprs|set VAR [EXPRS])}
Bind @samp{VAR} to each @samp{EXPR} in order.
Once the last @samp{EXPR} is reached, it is used repeatedly for the rest of the
loop.  With no @samp{EXPR}, @samp{VAR} is repeatedly bound to @samp{nil}.

@strong{NOTE}: Loops are locally scoped, so using this command does not always
have the same effect as using @samp{(do (setq VAR EXPR))}, as @samp{VAR} is
initialized to @samp{nil} before the loop starts.

@lisp
(loopy (repeat 5)
       (expr i 1 2 3)
       (collect coll i)
       (finally-return coll)) ; => '(1 2 3 3 3)

(loopy (repeat 5)
       (expr i 0 (1+ i))
       (collect coll i)
       (finally-return coll)) ; => '(0 1 2 3 4)
@end lisp
@end table

@findex group
@table @asis
@item @samp{(group [CMDS])}
Evaluate multiple loop commands, as if in a @samp{progn}.
This is similar to @samp{do}, but runs commands instead of normal Lisp
expressions.  Currently, this command is only useful when used with the
@samp{if} command.
@end table

@node Iteration and Looping Commands
@section Iteration and Looping Commands

Iteration commands bind local variables and determine when the loop ends.
If no command sets that condition, then the loop runs forever.

The @samp{-ref} (as in “reference”) commands create @code{setf}-able places instead of
true variables.  Like other commands, they can also use destructuring.  In
such cases, the variables in the sequence @samp{VAR} are also @code{setf}-able places
instead of true variables.

@findex array
@table @asis
@item @samp{(array VAR EXPR)}
Loop through the elements of the array @samp{EXPR}.

@lisp
(loopy (array i [1 2 3])
       (do (message "%d" i)))
@end lisp
@end table

@findex array-ref, arrayf
@table @asis
@item @samp{(array-ref|arrayf VAR EXPR)}
Loop through the elements of the array
@samp{EXPR}, binding @samp{VAR} as a @code{setf}-able place.

@lisp
(loopy (with (my-str "cat"))
       (array-ref i my-str)
       (do (setf i ?a))
       (finally-return my-str)) ; => "aaa"
@end lisp
@end table

@findex cons, conses
@table @asis
@item @samp{(cons|conses VAR EXPR [FUNC])}
Loop through the cons cells of @samp{EXPR}.
Optionally, find the cons cells via @samp{FUNC} instead of @samp{cdr}.

To avoid unneeded variables, when not destructuring, @samp{VAR} is initialized
to @samp{EXPR} instead of @code{nil}.

@lisp
(loopy (cons i '(1 2 3))
       (collect coll i)
       (finally-return coll)) ; => ((1 2 3) (2 3) (3))
@end lisp
@end table

@findex list
@table @asis
@item @samp{(list VAR EXPR [FUNC])}
Loop through the elements of the list @samp{EXPR}.
Optionally, update the list by @samp{FUNC} instead of @samp{cdr}.

@lisp
(loopy (list i (number-sequence 1 10 3)) ; Inclusive, so '(1 4 7 10).
       (do (message "%d" i)))
@end lisp
@end table

@findex list-ref, listf
@table @asis
@item @samp{(list-ref|listf VAR EXPR [FUNC])}
Loop through the elements of the
list @samp{EXPR}, binding @samp{VAR} as a @code{setf}-able place.  Optionally, update the
list by @samp{FUNC} instead of @samp{cdr}.

@lisp
(loopy (with (my-list '(1 2 3)))
       (list-ref i my-list)
       (do (setf i 7))
       (finally-return my-list)) ; Returns '(7 7 7).
@end lisp
@end table

@findex repeat
@table @asis
@item @samp{(repeat EXPR)}
Add a condition that the loop should stop after
@samp{EXPR} iterations.

@lisp
(loopy (repeat 3)
       (do (message "Messaged three times.")))
@end lisp

@item @samp{(repeat VAR EXPR)}
Add a condition that the loop should stop after
@samp{EXPR} iterations.  @samp{VAR} starts at 0, and is incremented by 1 at the
end of the loop.

@lisp
(loopy (repeat i 3)
       (do (message "%d" i)))
@end lisp
@end table

@findex seq
@table @asis
@item @samp{(seq VAR EXPR)}
Loop through the sequence @samp{val}, binding @samp{var} to
the elements of the sequence.

@lisp
(loopy (seq i [1 2 3])
       (collect coll i)
       (finally-return coll)) ; => (1 2 3)
@end lisp
@end table

@findex seq-ref, seqf
@table @asis
@item @samp{(seq-ref|seqf VAR EXPR)}
Loop through the elements of the sequence
@samp{val}, binding @samp{var} as a @code{setf}-able place.

@lisp
(loopy (with (my-seq '(1 2 3 4)))
       (seq-ref i my-seq)
       (do (setf i 7))
       (finally-return my-seq)) ; => '(7 7 7 7)
@end lisp
@end table

@node Accumulation Commands
@section Accumulation Commands

Accumulation commands are used to repeatedly update a variable using a
value.  In that way, they are something like shortcuts for several different
ways of using the @samp{expr} command.  For example, @samp{(sum my-sum my-var)} is
really just another way of saying @samp{(expr my-sum 0 (+ my-sum my-var))}.

If needed, you can refer to the same variable in multiple accumulation
commands, such as in the following.

@lisp
(loopy (list i '(1 2 3))
       (collect coll i)
       (collect coll (+ i 5))
       (finally-return coll)) ; => (1 6 2 7 3 8)
@end lisp

@cindex accumulation destructuring
Using a “destructuring” @samp{VAR} argument in accumulation commands works a bit
differently than how it would in iteration commands.  While iteration
commands just assign variables the values that make up the destructured
@samp{EXPR}, accumulation commands accumulate each of those values into their
respective variable in the sequence @samp{VAR}.

@lisp
;; => ((1 4) (2 5) (3 6))
(loopy (list elem '((1 2 3) (4 5 6)))
       (collect (coll1 coll2 coll3) elem)
       (finally-return coll1 coll2 coll3))

;; => (5 7 9)
(loopy (list elem '((1 2 3) (4 5 6)))
       (sum (sum1 sum2 sum3) elem)
       (finally-return sum1 sum2 sum3))

;; Returns the same values as above.
(loopy (list elem '((1 2 3) (4 5 6)))
       (expr sum1 (cl-first elem)  (+ sum1 (cl-first elem)))
       (expr sum2 (cl-second elem) (+ sum2 (cl-second elem)))
       (expr sum3 (cl-third elem)  (+ sum3 (cl-third elem)))
       (finally-return sum1 sum2 sum3))
@end lisp

@cindex implied/implicit return values
Using an accumulation command implies a return value.  If there are multiple
accumulations, or destructured accumulations, than the implied return value
of the loop is a list of those accumulated values in the order that their
respective command occurs in the loop body.  This implied return value can
be overridden by using the @samp{return} and @samp{return-from} loop commands or a
@samp{finally-return} macro argument.

@lisp
;; Note that `my-collection' is the first value in the implied return,
;; even though the collection happens after the first summation step.
;;
;; => (((4 5 6)) 5 7 9), for `my-collection', `sum1', `sum2', `sum3'
(loopy (list elem '((1 2 3) (4 5 6)))
       (when (equal elem '(4 5 6))
         (collect my-collection elem))
       (sum (my-sum1 my-sum2 my-sum3) elem))
@end lisp

@cindex implied/implicit accumulation variables
@vindex loopy-result
Like @code{cl-loop}, you do not need to supply a variable name to accumulation
commands.  If no variable is given, accumulation commands accumulate into the
the variable @code{loopy-result}.  This variable is accessible in the loop itself
and the @code{after-do}, @code{finally-do}, and @code{finally-return} macro arguments.  Note
that while its value can be changed in @code{after-do}, @code{finally-do} alone is too
late to effect what the macro returns without also using @code{finally-return}.

@lisp
;; => (1 2 3)
(cl-assert (equal (loopy (list i '(1 2 3))
                         (collect i)
                         (after-do (cl-return loopy-result)))

                  (loopy (list i '(1 2 3))
                         (collect i)
                         (finally-return loopy-result))))

;; => (0 1 2 3)
(cl-assert (equal (loopy (list i '(1 2 3))
                         (collect i)
                         (else-do (push 0 loopy-result)
                                  (cl-return loopy-result)))
                  (loopy (list i '(1 2 3))
                         (collect i)
                         (finally-do (push 0 loopy-result))
                         (finally-return loopy-result))))
@end lisp

Like in @code{cl-loop}, each accumulation command will use the same implied
variable.  This means that several uses of @samp{(collect my-value)}, for
example, will all collect values into the same variable.  If you want to use
to collect into separate variables, just specify a variable name like you
normally would.

The commands @samp{collect}, @samp{append}, and @samp{nconc} are more efficient if no @samp{VAR}
is provided, constructing the accumulated value backwards and then reversing
it, which is usually faster.  This means that if you want to use
destructuring with accumulation commands, it might be faster to use the
@samp{split} flag (@ref{Changing the Macro's Behavior with Flags}), which will make
@code{loopy} accumulate into separate implied variables instead of the same
@code{loopy-result}.  See that section for more details.

@lisp
;; Both of these example give the same result, but the latter can
;; expand into more efficient code.
;; There is also the `push-into' commands, which avoids this problem.

;; => ((1 4) (2 5) (3 6))
(loopy (list elem '((1 2 3) (4 5 6)))
       (collect (i j k) elem))

;; => ((1 4) (2 5) (3 6))
(loopy (flag split) ; Don't accumulate into same implicit variable.
       (list (i j k) '((1 2 3) (4 5 6)))
       (collect i)        ; Without the `split' flag,
       (collect j)        ; this would just produce
       (collect k))      ; (1 2 3 4 5 6).
@end lisp

@findex append
@table @asis
@item @samp{(append VAR EXPR)}
Repeatedly @code{append} the value of @samp{EXPR} to @samp{VAR}.
If @samp{VAR} is not provided, repeatedly @code{nconc} the @code{reverse} of @samp{EXPR} onto
the front of the implicit return value, and then @code{nreverse} the implicit
value at the end of the loop.

@samp{VAR} starts as @samp{nil}.

@lisp
(loopy (list i '((1 2 3) (4 5 6)))
       (append coll i)
       (finally-return coll)) ; => '(1 2 3 4 5 6)
@end lisp
@end table

@findex collect
@table @asis
@item @samp{(collect VAR EXPR)}
Collect the value of @samp{EXPR} into a list.  If @samp{VAR}
is not provided, repeatedly @code{push} the value of @samp{EXPR} into he implicit
return value, and then @code{nreverse} the implicit return value at the end of
the loop.

@samp{VAR} starts as @samp{nil}.

@lisp
;; => '(1 2 3)
(loopy (list i '(1 2 3))
       (collect i))

;; => '((1 2 3) ((1) (1 2) (1 2 3)))
(loopy (list i '(1 2 3))
       ;; Collect `i' into `coll1'.
       (collect coll1 i)
       ;; Collect `coll1' into a generated variable.
       (collect coll1))
@end lisp

If you want to @code{push} values into a provided variable (instead of
repeatedly appending a list of one element), use the @samp{push-into} command
(see below).
@end table

@findex concat
@table @asis
@item @samp{(concat VAR EXPR)}
Repeatedly @samp{concat} the value of @samp{EXPR} onto the
end of @samp{VAR}.  @samp{VAR} starts as @samp{nil}.  See the @samp{vconcat} command for
vectors.

@lisp
(loopy (list i '("a" "b" "c"))
       (concat str i)
       (finally-return str)) ; => "abc"
@end lisp
@end table

@findex count
@table @asis
@item @samp{(count VAR EXPR)}
Count the number of times that @samp{EXPR} evaluates to a
non-nil value, adding 1 to @samp{VAR} each time.  @samp{VAR} starts at 0.

@lisp
(loopy (list i '(1 nil 3 nil 5))
       (count non-nil-count i)
       (finally-return non-nil-count)) ; => 3
@end lisp
@end table

@findex max, maximize
@table @asis
@item @samp{(max|maximize VAR EXPR)}
Repeatedly set @samp{VAR} to the greater of @samp{VAR}
and the value of @samp{EXPR}.  @samp{VAR} starts at @samp{-1.0e+INF}, so that any other
value should be greater that it.

@lisp
(loopy (list i '(1 11 2 10 3 9 4 8 5 7 6))
       (max my-max i)
       (finally-return my-max)) ; => 11
@end lisp
@end table

@findex min, minimize
@table @asis
@item @samp{(min|minimize VAR EXPR)}
Repeatedly set @samp{VAR} to the lesser of @samp{VAR}
and the value of @samp{EXPR}.  @samp{VAR} starts at @samp{1.0e+INF}, so that any other
value should be less than it.

@lisp
(loopy (list i '(1 11 2 10 3 0 9 4 8 5 7 6))
       (min my-min i)
       (finally-return my-min)) ; => 0
@end lisp
@end table

@findex nconc
@table @asis
@item @samp{(nconc VAR EXPR)}
Repeatedly concatenate the value of @samp{EXPR} onto
@samp{VAR} with @samp{nconc}.  If @samp{VAR} is not provided, repeatedly @code{nconc} the
@code{nreverse} of @samp{EXPR} onto the front of the implicit return value, and then
@code{nreverse} that implicit return value at the end of the loop.

Unlike @code{append}, @code{nconc} does not concatenate copies of the lists, but
modifies @samp{VAR} directly.

@lisp
(loopy (list i '((1 2 3 4) (5 6 7 8)))
       (nconc my-new-list i)
       (finally-return my-new-list)) ; => '(1 2 3 4 5 6 7 8)
@end lisp
@end table

@findex push, push-into
@table @asis
@item @samp{(push|push-into VAR EXPR)}
Repeatedly @samp{push} @samp{EXPR} into @samp{VAR}.  @samp{VAR}
stars as @samp{nil}.

@lisp
(loopy (seq i [1 2 3])
       (push reversed i)
       (finally-return (nreverse reversed))) ; => '(1 2 3)
@end lisp
@end table

@findex sum
@table @asis
@item @samp{(sum VAR EXPR)}
Repeatedly set @samp{VAR} to the sum of the value of @samp{EXPR}
and @samp{VAR}.  @samp{VAR} starts at 0.

@lisp
(loopy (list i '(1 2 3 4))
       (sum my-sum i)
       (finally-return my-sum)) ; => 10
@end lisp
@end table

@findex vconcat
@table @asis
@item @samp{(vconcat VAR EXPR)}
Repeatedly @samp{vconcat} the value of @samp{EXPR} onto
@samp{VAR}.  @samp{VAR} starts as @samp{nil}.

@lisp
(loopy (list i '([1 2 3] [4 5 6]))
       (vconcat vector i)
       (finally-return vector)) ; => [1 2 3 4 5 6]
@end lisp
@end table

@node Control Flow
@section Control Flow

@menu
* Conditionals::
* Skipping an Iteration::
* Exiting the Loop Early::
@end menu

@node Conditionals
@subsection Conditionals

Conditional commands in @samp{loopy} can take multiple sub-commands, and work
like their Lisp counterparts.  There is therefore no need for an @samp{and}
command as used in @samp{cl-loop}.

@findex when
@table @asis
@item @samp{(when EXPR CMDS)}
Run @samp{CMDS} only if @samp{EXPR} is non-nil.

@lisp
;; Get only the inner lists with all even numbers.
;; => '((2 4 6) (8 10 12) (16 18 20))
(loopy (list i '((2 4 6) (8 10 12) (13 14 15) (16 18 20)))
       (when (loopy (list j i)
                    (when (cl-oddp j)
                      (return nil))
                    (else-do (cl-return t)))
         (collect only-evens i))
       (finally-return only-evens))
@end lisp
@end table

@findex if
@table @asis
@item @samp{(if EXPR CMDS)}
Run the first command if @samp{EXPR} is non-nil.
Otherwise, run the remaining commands.

@lisp
;; => '((7 5 3 1) (6 4 2) (3 3 3))
(loopy (seq i [1 2 3 4 5 6 7])
       (if (cl-oddp i)
           (push-into reversed-odds i)
         (push-into reversed-evens i)
         (push-into some-threes 3))
       (finally-return (list reversed-odds
                             reversed-evens
                             some-threes)))
@end lisp
@end table

@findex cond
@table @asis
@item @samp{(cond [(EXPR CMDS) [...]])}
For the first @samp{EXPR} to evaluate to
non-nil, run the following commands @samp{CMDS}.

@lisp
;; => '((2 4 6) (1 3 5) ("cat" "dog"))
(loopy (list i '(1 2 3 "cat" 4 5 6 "dog"))
       (cond
        ((not (numberp i)) (collect not-numbers i))
        ((cl-evenp i)      (collect evens i))
        (t                 (collect odds i)))
       (finally-return evens odds not-numbers))
@end lisp
@end table

@node Skipping an Iteration
@subsection Skipping an Iteration

@findex skip, continue
@table @asis
@item @samp{(skip|continue)}
Go to next loop iteration.

@lisp
;; => (2 4 6 8 12 14 16 18)
(loopy (seq i (number-sequence 1 20))
       (when (zerop (mod i 10))
         (skip))
       (when (cl-evenp i)
         (push-into my-collection i))
       (finally-return (nreverse my-collection)))
@end lisp
@end table

@node Exiting the Loop Early
@subsection Exiting the Loop Early

The loop is contained in a @samp{cl-block}, and these forms are all variations
of @samp{cl-return-from} underneath.  Indeed, you could use @samp{(do (cl-return-from
    NAME [EXPR]))} to achieve the same effect.

If multiple @samp{EXPR} are passes to the @samp{return} or @samp{return-from}, these
commands will return a list of those @samp{EXPR}.  If not @samp{EXPR} is given, @samp{nil}
is returned.

@findex return loop command
@table @asis
@item @samp{(return [EXPRS])}
Leave the current loop, returning @samp{[EXPRS]}.

@lisp
(loopy (with  (j 0))
       (do (cl-incf j))
       (when (> j 5)
         (return j))) ; => 6
@end lisp
@end table

@findex return-from
@table @asis
@item @samp{(return-from NAME [EXPRS])}
Leave the loop @samp{NAME}, returning @samp{[EXPRS]}.

@lisp
;; => 'bad-val?
(loopy outer-loop
       (list inner-list '((1 2 3) (1 bad-val? 1) (4 5 6)))
       (do (loopy (list i inner-list)
                  (when (eq i 'bad-val?)
                    (return-from outer-loop 'bad-val?)))))
@end lisp
@end table

@node Sub-loops
@section Sub-loops

@findex sub-loop, subloop, loop
@table @asis
@item @samp{(sub-loop|subloop|loop [CMDS])}
Create a sub-loop in the same lexical
environment as the top-level loop.
@end table


There are two main ways to have a sub-loop in @code{loopy}:

@enumerate
@item
Use another @code{loopy} call in a @samp{do} command.
@item
Use the @samp{sub-loop} (aliases @samp{loop} and @samp{subloop}) command.
@end enumerate

@samp{sub-loop} is better for accumulating into variables, as is does not create
its own result variable (unlike calling @code{loopy} again).  When using the
@samp{sub-loop} command, keep in mind the following:

@enumerate
@item
Only loop commands are valid within a sub-loop, not special macro
arguments like @samp{with} or @samp{finally-return}.

@lisp
;; GOOD:
;; => (8 9 10)
(loopy (with (a 7))
       (repeat 1)
       (loop (list i '(1 2 3))
             (collect (+ a i))))

;; BAD:
(loopy (repeat 1)
       (loop (with (a 7))
             (list i '(1 2 3))
             (collect (+ a i))))
@end lisp

@item
Sub-loops can be named, but they do not have their own return value. The
default loop name in @code{loopy} is @code{nil} for the top-level loop, but not for
sub-loops.  To return from the outer loop, you can use @samp{return-from}.

@lisp
;; Return from inner1 so never reach 4.
;; => ((3 5) (3 5))
(loopy (repeat 2)
       (loop inner1
             (list j '(3 4))
             (loop (list k '(5 6 7))
                   (if (= k 6)
                       (return-from inner1)
                     (collect (list j k))))))

;; Can use `return-from' on `nil' to refer to the
;; top-level loop, if un-named. Otherwise use the name.
(loopy (list i '(1 2 3))
       (loop (list j '(5 4 3))
             (if (= i j)
                 (return-from nil i)
               (collect (cons i j)))))
@end lisp

Because there is no return value for sub-loops, the @samp{return} and @samp{leave}
commands behave similarly.

@lisp
;; => ((1 .6) (2 . 6))
(loopy (list i '(1 2))
       (loop (list j '(6 7 8))
             (if (= j 7)
                 (return)
               (collect (cons i j)))))

;; => ((1 .6) (2 . 6))
(loopy (list i '(1 2))
       (loop (list j '(6 7 8))
             (if (= j 7)
                 (leave)
               (collect (cons i j)))))
@end lisp

@item
Variables used for iteration can be local to a sub-loop, but not
variables used for accumulation.

@lisp
;; GOOD:
;; => (0 1 2 3 1 2 3)
(loopy (repeat 2)
       (loop (list i '(1 2 3))
             (collect my-coll i))
       (finally-return (cons 0 my-coll)))

;; BAD:
;; Would not give (0 3 3).  Instead, signals error.
(loopy (repeat 2)
       (loop (list i '(1 2 3)))
       ;; Error:  `i' doesn't exist outside the sub-loop:
       (collect my-coll i)
       (finally-return (cons 0 my-coll)))
@end lisp
@end enumerate

@node Changing the Macro's Behavior with Flags
@chapter Changing the Macro's Behavior with Flags

@cindex flag
A ``flag'' is a symbol passed to the @samp{flag} or @samp{flags} macro argument, and
changes the macro's behavior.  Currently, flags affect what @code{loopy} uses to
perform destructuring (@code{pcase-let}, @code{seq-let}, @samp{dash}, or the default method)
and whether accumulation commands that don't specify a variable (such as
@samp{(collect collect-value)}) accumulate into one or several variables.

Flags are applied in order, so if you specify @samp{(flags seq pcase)} @code{loopy} will
use @code{pcase-let} for destructuring, not @code{seq-let}.

@vindex loopy-default-flags
If you wish to always use a flag, you can add that flag to the list
@code{loopy-default-flags}.  These can be overridden by any flag given in the
@samp{flag} macro argument.

The following flags are currently supported:

@cindex pcase flag
@table @asis
@item @samp{pcase}
Use @code{pcase-let} for destructuring.  See the @ref{Destructuring with pcase Patterns,@code{pcase} documentation,,elisp,}.
@end table
@cindex seq flag
@table @asis
@item @samp{seq}
Use @code{seq-let} for destructuring.  See the documentation for @ref{Sequence Functions,@code{seq-let},,elisp,}.
@end table
@cindex dash flag
@table @asis
@item @samp{dash}
Use the style of destructuring found in the @samp{dash} library, as if
via @ref{-let,@code{-let},,dash,}.
@end table
@cindex split flag
@table @asis
@item @samp{split}
Make accumulation commands with implicit variables accumulate into
separate variables instead of into @code{loopy-result}.
@end table
@cindex default flag
@table @asis
@item @samp{default}
Use the default behavior for all options.
@end table


For convenience, all flags (except @samp{default}) can be undone by prefixing them
with @samp{-} (a dash or minus sign), which reverts @code{loopy} to its default
behavior.

For example, if you have set @code{loopy-default-flags} to @samp{(dash split)} and wish
to only use the @samp{split} flag for a loop, you can use either @samp{(flags default
  split)} or, more simply, @samp{(flag -dash)}.  These prefixed flags only apply when
the unprefixed version is active.  That is, @samp{(flags pcase -dash)} is the same
as just @samp{(flags pcase)}, regardless of the value of @code{loopy-default-flags}, as
@samp{pcase} destructuring will override all uses of @samp{dash} destructuring as it
comes later in the list.  Similarly, @samp{(flags -dash dash)} and @samp{(flags -dash
  +dash)} leave @samp{dash} destructuring enabled, and @samp{(flags +dash -dash)} disables
@samp{dash} destructuring and uses the default behavior.

@cindex loopy-dash
@cindex loopy-pcase
@cindex loopy-seq
The destructuring flags (@samp{pcase}, @samp{seq}, and @samp{dash}) are separate libraries
(respectively, @samp{loopy-pcase}, @samp{loopy-seq}, and @samp{loopy-dash}) that must be
loaded after @samp{loopy}.  Currently, @samp{loopy-dash} is a separate package.

Below are some example of using the destructuring flags.  These flags do not
affect the destructuring of commands using generalized variables (i.e.,
@code{setf}-able places).

@lisp
;; => (((1 (2 3)) (4 (5 6))) ; whole
;;     (1 4)                 ; i
;;     (2 5)                 ; j
;;     (3 6))                ; k
(require 'loopy-dash)
(loopy (flag dash)
       (list elem '((1 (2 3)) (4 (5 6))))
       (collect (whole &as i (j k)) elem))

;; => ((1 4) (3 6))
(require 'loopy-pcase)
(loopy (flag pcase)
       (list elem '((1 (2 3)) (4 (5 6))))
       (collect `(,a (,_ ,b)) elem))

;; => ((1 6) (3 8) ([4 5] [9 10]))
(require 'loopy-seq)
(loopy (flag seq)
       (list elem '([1 2 3 4 5] [6 7 8 9 10]))
       (collect [a _ b &rest c] elem))
@end lisp

The @samp{split} flag can be more efficient than using destructuring with
accumulation commands.  Some accumulation commands can have more efficient
behavior when using implicit accumulation variables, since the variables can't
be accessed until the loop ends.  Using the @samp{split} flag allows you to do this
easily for multiple variables.

This can make a noticeable difference on large lists, but note that if you use
this feature, you will not be able to access the implicit return values with
loopy-result.  They will each have their own, uniquely generated name in
each loop.

@lisp
;; Both of these example give the same result, but the latter
;; can expand into more efficient code.
;;
;; There is also the `push-into' command, which avoids this problem when
;; used with `nreverse'.

;; => ((1 4) (2 5) (3 6))
(loopy (list elem '((1 2 3) (4 5 6)))
       (collect (i j k) elem))

;; => ((1 4) (2 5) (3 6))
(loopy (flag split) ; Don't accumulate into same implicit variable.
       (list (i j k) '((1 2 3) (4 5 6)))
       (collect i)
       (collect j)
       (collect k))
@end lisp

Below is an example of the @samp{split} flag.

@lisp
;; => (1 2 3 4 5)
(loopy (flag -split)
       (list i '(1 2 3 4 5))
       (if (cl-oddp i)
           (collect i)
         (collect i))
       ;; For un-named loops, the variable is `loopy-result'.
       (finally-return loopy-result))

;; => ((1 3 5) (2 4))
(loopy (flag split)
       (list i '(1 2 3 4 5))
       (if (cl-oddp i)
           (collect i)
         (collect i)))
@end lisp

@node Adding Custom Commands
@chapter Adding Custom Commands

@menu
* Background Information::
* A Small Example::
* A Slightly More Complicated Example::
@end menu

@node Background Information
@section Background Information

The core working of @samp{loopy} is taking a command and generating code that is
substituted into or around a loop body.

For example, parsing the command @samp{(list i '(1 2 3))} produces the following
list of instructions.  Some commands require the creation of unique temporary
variables, such as @samp{list-3717} in the below output.

@lisp
((loopy--iteration-vars list-3717 '(1 2 3))
 (loopy--latter-body setq list-3717 (cdr list-3717))
 (loopy--pre-conditions consp list-3717)
 (loopy--main-body setq i (car list-3717))
 (loopy--iteration-vars i nil))
@end lisp

The @code{car} of an instruction is the place to put code and the @code{cdr} of the
instruction is said code to put.  You can see that not all of the code to be
inserted is a valid Lisp form.  Instead of being evaluated as an expression,
some instructions insert pairs of names and values into variable lists like
in @code{let} and @code{let*} .

@multitable {aaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Place
@tab Code
@item @samp{loopy--iteration-vars}
@tab @samp{(list-3717 '(1 2 3))}
@item @samp{loopy--latter-body}
@tab @samp{(setq list-3717 (cdr list-3717))}
@item @samp{loopy--pre-conditions}
@tab @samp{(consp list-3717)}
@item @samp{loopy--main-body}
@tab @samp{(setq i (car list-3717))}
@item @samp{loopy--iteration-vars}
@tab @samp{(i nil)}
@end multitable

Commands are parsed by @samp{loopy--parse-loop-commands}, which receives a list of
commands and returns a list of instructions.  For commands that take
sub-commands as arguments (such as @samp{cond}, @samp{if}, and @samp{when}), more specific
parsing functions are called in a mutually recursive fashion (e.g.,
Function-1 uses Function-2 which uses Function-1, and so on).

For example, consider the function @samp{loopy--parse-if-command}, which parses
the @samp{if} command.  It needs to be able to group any code going to the loop
body under an @code{if}-form.  To do this, it uses @samp{loopy--parse-loop-command} to
turn its sub-commands into a list of instructions, and then checks the @samp{car}
of each instruction to whether the code should be inserted into the loop's
main body (and so whether it should be wrapped in the @code{if}-form).

@lisp
(cl-defun loopy--parse-if-command
    ((_ condition &optional if-true &rest if-false))
  "Parse the `if' loop command.  This takes the entire command.

- CONDITION is a Lisp expression.
- IF-TRUE is the first sub-command of the `if' command.
- IF-FALSE are all the other sub-commands."
  (let (full-instructions
        if-true-main-body
        if-false-main-body)
    (dolist (instruction (loopy--parse-loop-command if-true))
      (if (eq 'loopy--main-body (car instruction))
          (push (cdr instruction) if-true-main-body)
        (push instruction full-instructions)))
    (dolist (instruction (loopy--parse-loop-commands if-false))
      (if (eq 'loopy--main-body (car instruction))
          (push (cdr instruction) if-false-main-body)
        (push instruction full-instructions)))
    ;; Push the actual main-body instruction.
    (setq if-true-main-body
          (if (= 1 (length if-true-main-body))
              (car if-true-main-body)
            (cons 'progn (nreverse if-true-main-body))))

    ;; Return the list of instructions.
    (cons `(loopy--main-body
            . (if ,condition
                  ,if-true-main-body
                ,@@(nreverse if-false-main-body)))
          (nreverse full-instructions))))
@end lisp

The hardest part of this exchange is making sure the inserted code ends up in
the correct order.

A loop body command has 7 main places to put code:

@vindex loopy--generalized-vars
@table @asis
@item @samp{loopy--generalized-vars}
Lists of a symbol and a macro
expansion that will be given to @samp{cl-symbol-macrolet}.  This is used to
create named @code{setf}-able places.  The expansion you use depends on the kind
of sequence and how the it is updated.

For example, @samp{(list-ref i my-list)} declares @samp{i} to be a symbol which
expands to @samp{(car TEMP-VAR)}, in which @samp{TEMP-VAR} holds the value of
@samp{my-list}.  At the end of the loop body, @samp{TEMP-VAR} is set to its @samp{cdr},
ensuring that the next call to @samp{car} returns the correct value.
@end table

@vindex loopy--iteration-vars
@table @asis
@item @samp{loopy--iteration-vars}
Lists of a symbol and an expression that will be
given to @code{let*}.  This is used for initializing variables needed for
iteration commands, such as the @samp{i} in @samp{(list i '(1 2 3))} or to store the
list @samp{'(1 2 3)} in @samp{(list i '(1 2 3))}.  This also includes variables
needed for destructuring.
@end table

@vindex loopy--accumulation-vars
@table @asis
@item @samp{loopy--accumulation-vars}
Lists of a symbol and an expression that will
be given to @code{let*}.  This is used for initializing variables needed for
accumulation commands, such as the @samp{coll} in @samp{(collect coll my-val)} or any
variables needed for destructuring.
@end table

@vindex loopy--pre-conditions
@table @asis
@item @samp{loopy--pre-conditions}
Expressions that determine if the @samp{while}
loop runs/continues, such as whether a list still has elements in it.
If there is more than one expression, than all expressions are used in
an @samp{and} special form.
@end table

@vindex loopy--main-body
@table @asis
@item @samp{loopy--main-body}
Expressions that make up the main body of the
loop.
@end table

@vindex loopy--latter-body
@table @asis
@item @samp{loopy--latter-body}
Expressions that need to be run after the main
body, such as updating some of variables that determine when a loop ends.
@end table

@vindex loopy--post-conditions
@table @asis
@item @samp{loopy--post-conditions}
Expressions that determine whether the
@samp{while} loop continues, but checked after the loop body has run.  The
code from this is ultimately appended to the latter body before being
substituted in.
@end table

There are 4 more variables a loop command can push to, but they are derived
from the macro's arguments.  Adding to them after using a macro argument
might lead to unintended behavior.  You might wish to use them if, for
example, you are concerned with what happens after the loop exits/completes.

@vindex loopy--before-do
@table @asis
@item @samp{loopy--before-do}
Expressions to evaluate before the loop.  These are
derived from the @samp{before-do} macro argument.
@end table

@vindex loopy--after-do
@table @asis
@item @samp{loopy--after-do}
Expressions to evaluate after the loop completes
successfully.  These are derived from the @samp{after-do} macro argument.
@end table

@vindex loopy--final-do
@table @asis
@item @samp{loopy--final-do}
Expressions to evaluate after the loop completes,
regardless of success.  These are derived from the @samp{finally-do} macro
argument.
@end table

@vindex loopy--final-return
@table @asis
@item @samp{loopy--final-return}
An expression that is always returned by the
macro, regardless of any early returns in the loop body.  This is
derived from the @samp{finally-return} macro argument.
@end table

The structure of the macro’s expanded code depends on the features used
(e.g., @samp{loopy} won’t try to declare variables if none exist), but the result
will work similar to the below example.

@lisp
`(cl-symbol-macrolet ,loopy--generalized-vars
   (let* ,loopy--with-vars
     (let ,loopy--accumulation-vars
       (let* ,loopy--iteration-vars
         (let ((loopy--early-return-capture
                (cl-block ,loopy--name-arg
                  ,@@loopy--before-do
                  (while ,(cl-case (length loopy--pre-conditions)
                            (0 t)
                            (1 (car loopy--pre-conditions))
                            (t (cons 'and loopy--pre-conditions)))
                    (cl-tagbody
                     ,@@loopy--main-body
                     loopy--continue-tag
                     ,@@loopy--latter-body))
                  ,@@loopy--after-do
                  nil)))
           ,@@loopy--final-do
           ,(if loopy--final-return
                loopy--final-return
              'loopy--early-return-capture))))))
@end lisp

@node A Small Example
@section A Small Example

To implement a custom loop body command, @samp{loopy} needs two pieces of
information:
@enumerate
@item
The keyword that names your command
@item
The parsing function that can turn uses of your command into instructions.
@end enumerate

Importantly, your custom commands cannot share a name.

For example, say that you're tired of typing out
@samp{(do (message "Hello, %s" first last))} and would prefer to instead use
@samp{(greet FIRST [LAST])}.  This only requires pushing code into the main
loopy body, so the definition of the parsing function is quite simple.

@lisp
(cl-defun my-loopy-greet-command-parser ((_ first &optional last))
  "Greet one with first name FIRST and optional last name LAST."
  `((loopy--main-body . (if ,last
                            (message "Hello, %s %s" ,first ,last)
                          (message "Hello, %s" ,first)))))
@end lisp

@samp{loopy} will pass the entire command expression to the parsing function, and
expects back a list of instructions.

@vindex loopy-custom-command-parsers
To tell @samp{loopy} about this function, add it and the command name @samp{greet} to
the variable @samp{loopy-custom-command-parsers}.  When @code{loopy} doesn’t recognize
a command, it will search in this alist for a matching symbol.  The function
that is paired with the symbol receives the entire command expressions, and
should produce a list of valid instructions.

@lisp
(add-to-list 'loopy-custom-command-parsers
             '(greet . my-loopy-greet-command-parser))
@end lisp

After that, you can use your custom command in the loop body.

@lisp
(loopy (list name '(("John" "Deer") ("Jane" "Doe") ("Jimmy")))
       (greet (car name) (cadr name)))
@end lisp

By running @samp{M-x pp-macroexpand-last-sexp} on the above expression, you can
see that it expands to do what we want, as expected.

@lisp
(let ((g815 '(("John" "Deer")
              ("Jane" "Doe")
              ("Jimmy")))
      (name nil))
  (while (consp g815)
    (setq name (car g815))
    (if (cadr name)
        (message "Hello, %s %s"
                 (car name) (cadr name))
      (message "Hello, %s" (car name)))
    (setq g815 (cdr g815)))
  nil)
@end lisp

@node A Slightly More Complicated Example
@section A Slightly More Complicated Example

Lets say we want to emulate @samp{cl-loop}'s @samp{always} clause, which causes the
loop to return @samp{nil} if an expression evaluates to @samp{nil} and @samp{t} otherwise.

Here is an example:

@lisp
(cl-loop for i in (number-sequence 1 9) always (< i 10)) ; => t
@end lisp

Without a custom command, you could translate this using the following.

@lisp
(loopy (list i (number-sequence 1 9))
       (unless (< i 10) (return nil))
       (else-do (cl-return t)))
@end lisp

While its meaning is clear, this approach is certainly wordier.  Here's how
you could do it with a custom command:

@lisp
(cl-defun my--loopy-always-command-parser ((_ &rest conditions))
  "Parse a command of the form `(always [CONDITIONS])'.
If any condition is `nil', `loopy' should immediately return nil.
Otherwise, `loopy' should return t."
  (let (instructions)
    ;; Return t if loop completes successfully.
    (push `(loopy--after-do . (cl-return t)) instructions)
    ;; Check all conditions at the end of the loop body, forcing an exit if any
    ;; evaluate to nil.  Since the default return value of the macro is nil, we
    ;; don’t need to do anything else.
    ;;
    ;; NOTE: We must not add anything to `loopy--final-return', since that
    ;;       would override the value of any early returns.
    (dolist (condition conditions)
      (push `(loopy--post-conditions . ,condition) instructions))
    instructions))

(add-to-list 'loopy-custom-command-parsers
             (cons 'always #'my--loopy-always-command-parser))

;; One condition: => t
(loopy (list i (number-sequence 1 9)) (always (< i 10)))

;; Two conditions: => nil
(loopy (list i (number-sequence 1 9))
       (list j '(2 4 6 8 9))
       (always (< i 10) (cl-evenp j)))
@end lisp

This command (and equivalents of the @samp{never} and @samp{thereis} clauses) aren’t
provided by default on the assumption that modifying values normally derived
from macro arguments might prove confusing and unexpected.

@node How does it compare to @samp{cl-loop}?
@chapter How does it compare to @samp{cl-loop}?

@samp{loopy} should be comparable with @samp{cl-loop} for most things, keeping in
mind the following:
@itemize
@item
It is probably less efficient than @samp{cl-loop}, though I am so far trying to
keep the same logic that @samp{cl-loop} uses.
@item
It has more flexible control-flow commands, under which you can easily group
sub-commands, including assignments.
@item
It has a @samp{skip} command to skip the rest of the loop body and immediately
start the next iteration.  Of course, a similar effect could be achieved
using the @samp{when} or @samp{unless} commands.
@end itemize

@samp{loopy} is not always one-to-one replacement for @samp{cl-loop}, but it is easy to
use and extend, and performs well in the cases that it already handles.

Below is a simple example of @samp{loopy} vs @samp{cl-loop}.

@lisp
(require 'cl-lib)
(cl-loop with some-thing = 5
         for i from 1 to 100
         do (message "I is %s" i)
         when (> (+ i 5) 20)
         return (format "Done: %d" i))

(require 'loopy)
(loopy (with (some-thing 5))
       (list i (number-sequence 1 100))
       (do (message "I is %s" i))
       (when (> (+ i 5) 20)
         (return (format "Done: %d" i))))
@end lisp

The main benefit (I believe) of Loopy is clearer grouping of commands under
conditionals while still using a clean syntax, such as in the below example.

@lisp
;; => '((2 4) (4 8) (6 12) (8 16) (10 20))
(loopy (list i (number-sequence 1 10))
       (when (cl-evenp i)
         (expr once i)
         (expr twice (* 2 i))
         (collect together (list once twice)))
       (finally-return together))
@end lisp

In my experience, @samp{cl-loop} does not allow the easy grouping of assignment
statements under a @samp{when} condition.  For example, below is something I would
like to try to do with @samp{cl-loop}.

I am aware that in this example the @samp{for} statements aren't necessary and that
the @samp{collect} statements would be sufficient, but (when I come across things
like this in my work) I would like to use them to declare variables for
readability purposes.

@lisp
(require 'cl-lib)
(save-match-data
  (cl-loop with pattern = "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"
           for line in (split-string "Line1-Data1\nBad\nLine2-Data2")
           when (string-match pattern line)
           for line-num = (concat "L" (match-string 1 line))
           and for data-num = (concat "D" (match-string 2 line))

           ;; … Further processing now that data is named …

           and collect line-num into line-nums
           and collect data-num into data-nums
           finally return (list line-nums data-nums)))

;; Normal Elisp:
(save-match-data
  (let ((pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)")
        (line-nums)
        (data-nums))
    (dolist (line (split-string "Line1-Data1\nBad\nLine2-Data2"))
      (when (string-match pattern line)
        (let ((line-num (concat "L" (match-string 1 line)))
              (datum-num (concat "D" (match-string 2 line))))

          ;; … Further processing now that data is named …

          (push line-num line-nums)
          (push datum-num data-nums))))
    (list (nreverse line-nums) (nreverse data-nums))))
@end lisp

Here is how one could currently do it with @samp{loopy}:

@lisp
(require 'loopy)
(save-match-data
  (loopy (with (pattern "^Line\\([[:digit:]]\\)-Data\\([[:digit:]]\\)"))
         (list line (split-string "Line1-Data1\nBad\nLine2-Data2"))
         (when (string-match pattern line)
           (expr line-num (concat "L" (match-string 1 line)))
           (expr datum-num (concat "D" (match-string 2 line)))

           ;; … Further processing now that data is named …

           (collect line-nums line-num)
           (collect data-nums datum-num))
         (finally-return line-nums data-nums)))
@end lisp

I believe that the value of the macro increases for longer loop bodies with
several conditional commands.

Another nice ability, one that I'm not sure @samp{cl-loop} has, is a specific
command for skipping/continuing a loop iteration.  Of course, one could also
re-organize code under a conditional command like @samp{when} to achieve the same
effect.

@lisp
;; Returns even numbers that aren't multiples of 10.
(loopy (list i (number-sequence 1 20))
       (when (zerop (mod i 10))
         (skip))
       (when (cl-evenp i)
         (push-into my-collection i))
       (finally-return (nreverse my-collection))) ; => (2 4 6 8 12 14 16 18)
@end lisp

@menu
* Translating from @samp{cl-loop}::
@end menu

@node Translating from @samp{cl-loop}
@section Translating from @samp{cl-loop}

@menu
* For Clauses::
* Iteration Clauses::
* Accumulation Clauses::
* Other Clauses::
@end menu

@node For Clauses
@subsection For Clauses

As Emacs has many functions that return lists, there is no need to implement
an exact equivalent for every @samp{for}-clause that @samp{cl-loop} has.  Instead, one
can just iterate through the return value of the appropriate function using
the @samp{list} command.

@multitable {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem @samp{cl-loop}
@tab @samp{loopy}
@item @samp{for VAR from EXPR1 to EXPR2 by EXPR3}
@tab @samp{(list VAR (number-sequence EXPR1 EXPR2 EXPR3))}
@item @samp{for VAR in LIST [by FUNCTION]}
@tab @samp{(list VAR LIST [FUNC])}
@item @samp{for VAR on LIST [by FUNCTION]}
@tab @samp{(cons VAR VAL [FUNC])}
@item @samp{for VAR in-ref LIST by FUNCTION}
@tab @samp{(list-ref VAR LIST [FUNC])}
@item @samp{for VAR across ARRAY}
@tab @samp{(array VAR ARRAY)}
@item @samp{for VAR across-ref ARRAY}
@tab @samp{(array-ref VAR ARRAY)}
@item @samp{for VAR being the elements of SEQUENCE}
@tab @samp{(seq VAR SEQUENCE)}
@item @samp{for VAR being the elements of-ref SEQUENCE}
@tab @samp{(seq-ref VAR SEQUENCE)}
@item @samp{for VAR being the symbols [of OBARRAY]}
@tab None so far.  Use @code{mapatoms}.
@item @samp{for VAR being the hash-keys of HASH-TABLE}
@tab @samp{(list VAR (hash-table-keys HASH-TABLE))}
@item @samp{for VAR being the hash-values of HASH-TABLE}
@tab @samp{(list VAR (hash-table-values HASH-TABLE))}
@item @samp{for VAR being the key-codes of KEYMAP}
@tab None so far.  Use @code{map-keymap}.
@item @samp{for VAR being the key-bindings of KEYMAP}
@tab None so far.  Use @code{map-keymap}.
@item @samp{for VAR being the key-seqs of KEYMAP}
@tab None so far.
@item @samp{for VAR being the overlays [of BUFFER]}
@tab None so far.  Use @code{overlay-lists}.
@item @samp{for VAR being the intervals [of BUFFER]}
@tab None so far.
@item @samp{for VAR being the frames}
@tab @samp{(list VAR (frame-list))}
@item @samp{for VAR being the windows [of FRAME]}
@tab @samp{(list VAR (window-list FRAME))}
@item @samp{for VAR being the buffers}
@tab @samp{(list VAR (buffer-list))}
@item @samp{for VAR = EXPR1 then EXPR2}
@tab @samp{(expr VAR EXPR1 EXPR2)}
@end multitable

@node Iteration Clauses
@subsection Iteration Clauses

@multitable {aaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaa}
@headitem @samp{cl-loop}
@tab @samp{loopy}
@item @samp{repeat INT}
@tab @samp{(repeat INT)}
@item @samp{while COND}
@tab @samp{(while COND)}
@item @samp{until COND}
@tab @samp{(until COND)}
@item @samp{iter-by iterator}
@tab None so far.
@end multitable

The clauses @samp{always}, @samp{never}, and @samp{thereis} can be replaced by a
combination of an exiting command and the @samp{after-do} (also written
@samp{else-do}) macro argument.  Below is an example from the CL Lib manual.

@lisp
;; With `cl-loop':
(if (cl-loop for size in size-list always (> size 10))
    (only-big-sizes)
  (some-small-sizes))

;; With `loopy':
;; Depends on whether the functions have return values.
(loopy (list size size-list)
       ;; `return` is just a wrapper for `cl-return`.
       (when (< size 10) (return (some-small-sizes)))
       ;; Only runs if loop doesn't exit early.
       (else-do (cl-return (only-big-sizes))))
@end lisp

A seen in the above example, @samp{loopy} does not always have a one-to-one
translation to @samp{cl-loop} (@ref{A Slightly More Complicated Example, , though you could try a custom command}).

It is not an explicit goal to be able to replace all uses of @samp{cl-loop} with
@samp{loopy}.  I'd prefer that @samp{loopy} be useful in places where @samp{cl-loop} might
not be enough, instead of forcing @samp{loopy} into places where @samp{cl-loop}
already works well.

Other options in the above example include using @samp{cl-every},
@samp{seq-every-p}, Dash’s @samp{-all?}, etc.

@node Accumulation Clauses
@subsection Accumulation Clauses

In @samp{loopy}, when accumulation commands are not given a @samp{VAR}, they
accumulate into different variables.  If you want accumulations to act on
the same variable, you must give the same @samp{VAR}.

@multitable {aaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaa}
@headitem @samp{cl-loop}
@tab @samp{loopy}
@item @samp{append EXPR into VAR}
@tab @samp{(append VAR EXPR)}
@item @samp{collect EXPR into VAR}
@tab @samp{(collect VAR EXPR)}
@item @samp{concat EXPR into VAR}
@tab @samp{(concat VAR EXPR)}
@item @samp{count EXPR into VAR}
@tab @samp{(count VAR EXPR)}
@item @samp{maximize EXPR into VAR}
@tab @samp{(max VAR EXPR)}
@item @samp{minimize EXPR into VAR}
@tab @samp{(min VAR EXPR)}
@item @samp{nconc EXPR into VAR}
@tab @samp{(nconc VAR EXPR)}
@item @samp{sum EXPR into VAR}
@tab @samp{(sum VAR EXPR)}
@item @samp{vconcat EXPR into VAR}
@tab @samp{(vconcat VAR EXPR)}
@end multitable

@node Other Clauses
@subsection Other Clauses

In @samp{loopy}, @samp{if}, @samp{when}, and @samp{unless} can take multiple loop commands as
arguments, and operate more like their Lisp counterparts.

This means that @samp{if} is not a synonym for @samp{when}.  Just like the normal Lisp
special form @samp{if}, @samp{(if COND cmd1 cmd2 cmd3)} only runs @samp{cmd1} if @samp{COND}
evaluates to non-nil, and only runs commands @samp{cmd2} and @samp{cmd3} if @samp{COND}
evaluates to @samp{nil}.

@samp{loopy} also provides the command @samp{cond}, which works like the normal Lisp
special form @samp{cond}.

@multitable {aaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem @samp{cl-loop}
@tab @samp{loopy}
@item @samp{with var = value}
@tab @samp{(with (VAR VALUE))} as a macro argument
@item @samp{if COND clause}
@tab @samp{(if COND CMDS)} as a loop command
@item @samp{when COND clause}
@tab @samp{(when COND CMDS)} as a loop command
@item @samp{unless COND clause}
@tab @samp{(unless COND CMDS)} as a loop command
@item @samp{named NAME}
@tab @samp{NAME} as a macro argument
@item @samp{initially [do] EXPRS}
@tab @samp{(before-do EXPRS)} as a macro argument
@item @samp{finally [do] EXPRS}
@tab @samp{(finally-do EXPRS)} as a macro argument
@item @samp{finally return EXPR}
@tab @samp{(finally-return EXPR)} as a macro argument
@item @samp{do EXPRS}
@tab @samp{(do EXPRS)} as a loop command
@item @samp{return EXPR}
@tab @samp{(return EXPR)} as a loop command
@end multitable

@node Real-World Examples
@chapter Real-World Examples

This section contains examples of loops that exist in real-world commands.  To
see these loops in context, full examples of those commands can be found in
the file @uref{loopy-examples.el} (containing the library @samp{loopy-examples}) that
comes with this package.

One command that could see a benefit from using @samp{loopy} is @samp{selectrum-swiper}
from the Selectrum wiki @footnote{@uref{https://github.com/raxod502/selectrum/wiki/Useful-Commands#jumping-to-lines}}.  This command allows a user to jump to
a matched line in the buffer.  Candidates are created by looping through text
lines, formatting non-empty lines and collecting the formatted lines into a
list of candidates.  At the same time, it selects a default candidate by
finding the non-empty line closest to the current line.

Here is the main portion of the command, which uses @samp{cl-loop}.

@lisp
;; ...
(cl-loop
 with buffer-lines = (split-string (buffer-string) "\n")
 with number-format = (concat "L%0"
                              (number-to-string
                               (length (number-to-string
                                        (length buffer-lines))))
                              "d: ")

 with formatted-candidates = nil
 for line-text in buffer-lines
 for line-num = (line-number-at-pos (point-min) t) then (1+ line-num)

 with default-candidate = nil
 with prev-distance-to-default-cand = 1.0e+INF ; This updated later.
 for distance-to-default-cand = (abs (- current-line-number line-num))

 unless (string-empty-p line-text)      ; Just skip empty lines.
 do
 ;; Find if we’ve started to move away from the current line.
 (when (null default-candidate)
   (when (> distance-to-default-cand
            prev-distance-to-default-cand)
     (setq default-candidate (cl-first formatted-candidates)))
   (setq prev-distance-to-default-cand distance-to-default-cand))

 ;; Format current line and collect candidate.
 (push (propertize line-text
                   'selectrum-candidate-display-prefix
                   (propertize (format number-format line-num)
                               'face 'completions-annotations)
                   'line-num line-num)
       formatted-candidates)

 finally return (list default-candidate
                      (nreverse formatted-candidates)))
;; ...
@end lisp

The limitations of @samp{cl-loop}'s @samp{when} clause encourages relying on Lisp
expressions rather than clauses for processing.  To use those Lisp
expressions, one must declare more variables with the @samp{with} clause to ensure
that those variables are locally scoped.

Here is how it could be done with @samp{loopy}:

@lisp
;; ...
(loopy
 (with (buffer-text-lines (split-string (buffer-string) "\n"))
       (number-format (concat "L%0"
                              (number-to-string
                               (length (number-to-string
                                        (length buffer-text-lines))))
                              "d: ")))
 (list line-text buffer-text-lines)
 (expr line-num (line-number-at-pos (point-min) t)
       (1+ line-num))
 (unless (string-empty-p line-text)
   (push-into formatted-candidates
              (propertize line-text
                          'selectrum-candidate-display-prefix
                          (propertize (format number-format line-num)
                                      'face 'completions-annotations)
                          'line-num line-num))
   ;; There are a few different ways that you could express
   ;; this.
   (when (null default-candidate)
     (expr prev-dist +1.0e+INF dist-to-default-cand)
     (expr dist-to-default-cand (abs (- current-line-number
                                        line-num)))
     (when (> dist-to-default-cand prev-dist)
       (expr default-candidate (cl-second formatted-candidates)))))
 (finally-return default-candidate (nreverse formatted-candidates)))
;; ...
@end lisp

We can see that most of the loop commands are easily grouped under the
@samp{unless} command.  This allows for less noise, as we do not need to declare
variables or fall back to using more Lisp expressions.

Another good example is the command @samp{selectrum-outline} from the same page.
This command is similar to @samp{selectrum-swiper}, but has a slightly more
complicated processing portion.

The code loops through each line in the buffer, searching for lines that match
a pre-determined regular expression.  The match data is used to determine the
heading level (top level, second level, etc.) and the actual heading text.
The loop produces formatted candidates by prepending this heading text with
the text of parent headings, as determined by the heading level.  At the same
time, the loop selects the current heading as the default candidate.

Instead of using @samp{cl-loop}, this command is written in conventional Emacs
Lisp.

@lisp
;; ...
(let (;; Get the basic information of each heading in the accessible
      ;; portion of the buffer.
      (buffer-lines (split-string (buffer-string) "\n"))
      (line-number 0)
      (line-number-format)

      ;; Finding the default heading
      (default-heading)
      (current-line-number (line-number-at-pos (point)))

      ;; Keeping track of the tree.
      (backwards-prefix-list)
      (prev-heading-text)
      (prev-heading-level)

      ;; Backwards result of the ‘dolist'. Will ‘nreverse’.
      (formatted-headings))

  (setq line-number-format
        (concat "L%0"
                (number-to-string
                 (length (number-to-string (length buffer-lines))))
                "d: "))

  (save-match-data
    (dolist (text-line buffer-lines)
      ;; Increment line number when moving to next.
      (cl-incf line-number)
      (when (string-match heading-regexp text-line)
        (let ((heading-text (match-string-no-properties 2 text-line))
              (heading-level
               (length (match-string-no-properties 1 text-line))))

          ;; Make sure this has a valid value when we first compare.  The
          ;; first comparison should be equal, so that nothing is
          ;; needlessly added to the prefix list, which causes bad
          ;; formatting.
          (unless prev-heading-level
            (setq prev-heading-level heading-level))

          ;; Decide whether to update the prefix list and the previous
          ;; heading level.
          (cond
           ;; If we've moved to a greater level (further down the tree),
           ;; add the previous heading to the heading prefix list so
           ;; that we can prepend it to the current heading when
           ;; formatting.
           ((> heading-level prev-heading-level)
            (setq backwards-prefix-list (cons prev-heading-text
                                              backwards-prefix-list)
                  prev-heading-level heading-level))
           ;; Otherwise, if we've moved to a lower level (higher up the
           ;; tree), and need to remove the most recently added prefix
           ;; from the list (i.e., go from '(c b a) back to '(b a)).
           ((< heading-level prev-heading-level)
            (setq backwards-prefix-list (last backwards-prefix-list
                                              heading-level)
                  prev-heading-level heading-level)))

          ;; Regardless of what happens, update the previous heading text.
          (setq prev-heading-text heading-text)

          ;; Decide whether the previous formatted heading was the
          ;; default.
          (when (and (null default-heading)
                     (> line-number current-line-number))
            (setq default-heading (cl-first formatted-headings)))

          ;; Finally, add to list of formatted headings.
          ;; Create heading of form "L#: a/b/c" as:
          ;; - having a text property holding the line number
          ;; - prepended with a formatted line number,
          ;;   with the face ‘completions-annotations’.
          (push (propertize
                 (concat (string-join (reverse backwards-prefix-list) "/")
                         (and backwards-prefix-list "/")
                         heading-text)
                 'line-number line-number
                 'selectrum-candidate-display-prefix
                 (propertize
                  (format line-number-format line-number)
                  'face 'completions-annotations))
                formatted-headings)))))
  ;; ...
  )
@end lisp

Here is a version in @samp{loopy} which is more of a straight translation than a
re-working:

@lisp
;; ...
(loopy
 (with (buffer-lines (split-string (buffer-string) "\n"))
       (line-number-format
        (concat "L%0"
                (number-to-string
                 (length (number-to-string (length buffer-lines))))
                "d: ")))
 (expr line-number 1 (1+ line-number))
 (list text-line buffer-lines)
 (when (string-match heading-regexp text-line)
   (expr heading-text
         (match-string-no-properties 2 text-line))
   (expr heading-level
         (length (match-string-no-properties 1 text-line)))

   ;; Decide whether to update the prefix list and the previous
   ;; heading level.
   (cond
    ;; If we've moved to a greater level (further down the tree),
    ;; add the previous heading to the heading prefix list so that
    ;; we can prepend it to the current heading when formatting.
    ((> heading-level (or prev-heading-level heading-level))

     (push-into backwards-prefix-list prev-heading-text)
     (expr prev-heading-level heading-level))
    ;; Otherwise, if we've moved to a lower level (higher up the
    ;; tree), and need to remove the most recently added prefix
    ;; from the list (i.e., go from '(c b a) back to '(b a)).
    ((< heading-level (or prev-heading-level heading-level))
     (expr backwards-prefix-list (last backwards-prefix-list
                                       heading-level))
     (expr prev-heading-level heading-level)))

   ;; Regardless of what happens, update the previous heading
   ;; text.
   (expr prev-heading-text heading-text)

   ;; Decide whether the previous formatted heading was the
   ;; default.
   (when (and (null default-heading)
              (> line-number current-line-number))
     (expr default-heading (car formatted-headings)))

   ;; Finally, add to list of formatted headings.
   ;; Create heading of form "L#: a/b/c" as:
   ;; - having a text property holding the line number
   ;; - prepended with a formatted line number,
   ;;   with the face ‘completions-annotations’.
   (push-into
    formatted-headings
    (propertize
     (concat (string-join
              (reverse backwards-prefix-list) "/")
             (and backwards-prefix-list "/")
             heading-text)
     'line-number line-number
     'selectrum-candidate-display-prefix
     (propertize (format line-number-format line-number)
                 'face 'completions-annotations))))
 (finally-return default-heading (nreverse formatted-headings)))
;; ...
@end lisp

In my opinion, the @samp{loopy} version is a bit cleaner.  Even when following the
same flow of logic, you still get the benefit of less typing with no loss in
clarity.

If one were writing code like this often (say, in a library), then the loop
body could be simplified even further with @ref{Adding Custom Commands, , custom commands}.

@node Keyword and Command Index
@chapter Keyword and Command Index

@printindex fn

@node Variable Index
@chapter Variable Index

@printindex vr

@node Concept Index
@chapter Concept Index

@printindex cp

@bye